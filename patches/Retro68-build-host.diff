diff -Naur Retro68.old/libelf/CMakeLists.txt Retro68/libelf/CMakeLists.txt
--- Retro68.old/libelf/CMakeLists.txt	2020-03-19 19:23:49.953534163 -0700
+++ Retro68/libelf/CMakeLists.txt	2020-05-01 20:19:28.343938249 -0700
@@ -1,4 +1,4 @@
-file(GLOB ELF_FILES src/*.c src/*.h include/*.h)
+file(GLOB ELF_FILES src/*.cpp src/*.c src/*.h include/*.h)
 add_library(ELF ${ELF_FILES}
 	)
 target_include_directories(ELF PRIVATE src)
diff -Naur Retro68.old/libelf/include/libelf.h Retro68/libelf/include/libelf.h
--- Retro68.old/libelf/include/libelf.h	2020-03-19 19:23:49.965534163 -0700
+++ Retro68/libelf/include/libelf.h	2020-03-21 22:26:16.376225732 -0700
@@ -187,6 +187,8 @@
   ELF_K_NUM
 } Elf_Kind;
 
+#define uid_t int
+#define gid_t int
 
 /* Archive member header.  */
 typedef struct
diff -Naur Retro68.old/libelf/src/common.h Retro68/libelf/src/common.h
--- Retro68.old/libelf/src/common.h	2020-03-19 19:23:49.965534163 -0700
+++ Retro68/libelf/src/common.h	2020-03-22 11:08:21.989911866 -0700
@@ -30,7 +30,29 @@
 #ifndef _COMMON_H
 #define _COMMON_H       1
 
-#include <ar.h>
+//#include <ar.h>
+#ifndef INCLUDED_AR_H
+#define INCLUDED_AR_H
+#define ARMAG  "!<arch>\n"
+#define SARMAG  8
+
+#define ARFMAG  "`\n"
+
+struct ar_hdr
+{
+    char ar_name[ 16 ];
+    char ar_date[ 12 ];
+    char ar_uid[ 6 ];
+    char ar_gid[ 6 ];
+    char ar_mode[ 8 ];
+    char ar_size[ 10 ];
+    char ar_fmag[ 2 ];
+};
+
+#define SARFMAG  2
+#define SARHDR  sizeof( struct ar_hdr )
+#endif
+
 #include <stdlib.h>
 #include <string.h>
 #include "portable_endian.h"
diff -Naur Retro68.old/libelf/src/elf32_updatefile.c Retro68/libelf/src/elf32_updatefile.c
--- Retro68.old/libelf/src/elf32_updatefile.c	2020-03-19 19:23:49.973534163 -0700
+++ Retro68/libelf/src/elf32_updatefile.c	2020-05-01 20:20:07.223940269 -0700
@@ -38,7 +38,9 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
-#include <sys/mman.h>
+//#include <sys/mman.h>
+#include "mman.h"
+#include "sysconf.h"
 
 #include <system.h>
 #include "libelfP.h"
diff -Naur Retro68.old/libelf/src/elf_begin.c Retro68/libelf/src/elf_begin.c
--- Retro68.old/libelf/src/elf_begin.c	2020-03-19 19:23:49.981534163 -0700
+++ Retro68/libelf/src/elf_begin.c	2020-05-02 10:21:39.669961387 -0700
@@ -39,7 +39,9 @@
 #include <stddef.h>
 #include <string.h>
 #include <unistd.h>
-#include <sys/mman.h>
+//#include <sys/mman.h>
+#include "mman.h"
+#include "fcntl.h"
 #include <sys/stat.h>
 
 #include <system.h>
diff -Naur Retro68.old/libelf/src/elf_end.c Retro68/libelf/src/elf_end.c
--- Retro68.old/libelf/src/elf_end.c	2020-03-19 19:23:49.985534163 -0700
+++ Retro68/libelf/src/elf_end.c	2020-03-22 12:39:40.626151629 -0700
@@ -34,7 +34,8 @@
 #include <assert.h>
 #include <stddef.h>
 #include <stdlib.h>
-#include <sys/mman.h>
+//#include <sys/mman.h>
+#include "mman.h"
 
 #include "libelfP.h"
 
diff -Naur Retro68.old/libelf/src/elf_getaroff.c Retro68/libelf/src/elf_getaroff.c
--- Retro68.old/libelf/src/elf_getaroff.c	2020-03-19 19:23:49.989534163 -0700
+++ Retro68/libelf/src/elf_getaroff.c	2020-05-02 10:43:51.918506306 -0700
@@ -38,7 +38,7 @@
 #include "libelfP.h"
 
 
-off_t
+int64_t
 elf_getaroff (Elf *elf)
 {
   /* Be gratious, the specs demand it.  */
diff -Naur Retro68.old/libelf/src/elf_getbase.c Retro68/libelf/src/elf_getbase.c
--- Retro68.old/libelf/src/elf_getbase.c	2020-03-19 19:23:49.989534163 -0700
+++ Retro68/libelf/src/elf_getbase.c	2020-05-02 10:49:31.398321381 -0700
@@ -37,7 +37,7 @@
 #include "libelfP.h"
 
 
-off_t
+int64_t
 elf_getbase (Elf *elf)
 {
   return elf == NULL ? (off_t) -1 : elf->start_offset;
diff -Naur Retro68.old/libelf/src/elf_getdata_rawchunk.c Retro68/libelf/src/elf_getdata_rawchunk.c
--- Retro68.old/libelf/src/elf_getdata_rawchunk.c	2020-03-19 19:23:49.989534163 -0700
+++ Retro68/libelf/src/elf_getdata_rawchunk.c	2020-05-02 12:25:35.721715974 -0700
@@ -41,7 +41,7 @@
 #include "common.h"
 
 Elf_Data *
-elf_getdata_rawchunk (Elf *elf, off_t offset, size_t size, Elf_Type type)
+elf_getdata_rawchunk (Elf *elf, int64_t offset, size_t size, Elf_Type type)
 {
   if (unlikely (elf == NULL))
     return NULL;
diff -Naur Retro68.old/libelf/src/elf_update.c Retro68/libelf/src/elf_update.c
--- Retro68.old/libelf/src/elf_update.c	2020-03-19 19:23:50.001534163 -0700
+++ Retro68/libelf/src/elf_update.c	2020-05-09 20:14:18.796001994 -0700
@@ -34,7 +34,10 @@
 #include <libelf.h>
 #include <fcntl.h>
 #include <unistd.h>
-#include <sys/mman.h>
+//#include <sys/mman.h>
+#include "mman.h"
+#include "fchmod.h"
+#include "fallocate.h"
 #include <sys/stat.h>
 
 #include "libelfP.h"
@@ -148,7 +151,7 @@
 }
 
 
-off_t
+int64_t
 elf_update (Elf *elf, Elf_Cmd cmd)
 {
   size_t shnum;
diff -Naur Retro68.old/libelf/src/fallocate.cpp Retro68/libelf/src/fallocate.cpp
--- Retro68.old/libelf/src/fallocate.cpp	1969-12-31 16:00:00.000000000 -0800
+++ Retro68/libelf/src/fallocate.cpp	2020-05-09 19:56:28.092134443 -0700
@@ -0,0 +1,519 @@
+#include <windows.h>
+#include <errno.h>
+#include <io.h>
+#include "fallocate.h"
+
+// Check windows
+#if !defined(_WIN32) && !defined(_WIN16) && !defined(_WIN64)
+#if WIN16 || _WIN16_ || ___WIN16 || ___WIN16__ || WIN32 || _WIN32_ || ___WIN32 || ___WIN32__ || WIN64 || _WIN64_ || ___WIN64 || ___WIN64__
+#if WIN64 || _WIN64_ || ___WIN64 || ___WIN64__
+#define _WIN64
+#elif WIN16 || _WIN16_ || ___WIN16 || ___WIN16__
+#define _WIN16
+#else
+#define _WIN32
+#endif
+#endif
+#endif
+
+// Check GCC
+#if !defined(_WIN32) && !defined(_WIN16) && !defined(_WIN64)
+#if __GNUC__
+#if __x86_64__ || __ppc64__
+#define _WIN64
+#else
+#define _WIN32
+#endif
+#endif
+#endif
+
+#ifndef ANYSIZE_ARRAY
+#define ANYSIZE_ARRAY 1
+#endif
+
+typedef struct _LLUID {
+  DWORD LowPart;
+  LONG  HighPart;
+} LLUID, *PLLUID;
+
+typedef struct _LLUID FAR * LPLLUID;
+
+typedef struct _LLUID_AND_ATTRIBUTES {
+  LLUID  Luid;
+  DWORD Attributes;
+} LLUID_AND_ATTRIBUTES, *PLLUID_AND_ATTRIBUTES;
+
+typedef struct _LLUID_AND_ATTRIBUTES FAR *LPLLUID_AND_ATTRIBUTES;
+
+typedef struct _LTOKEN_PRIVILEGES {
+  DWORD               PrivilegeCount;
+  LLUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];
+} LTOKEN_PRIVILEGES, *PLTOKEN_PRIVILEGES;
+
+typedef struct _LTOKEN_PRIVILEGES FAR *LPLTOKEN_PRIVILEGES;
+
+#ifndef TOKEN_QUERY
+#define TOKEN_QUERY 0x00000008
+#endif
+
+#ifndef TOKEN_ADJUST_PRIVILEGES
+#define TOKEN_ADJUST_PRIVILEGES 0x00000020
+#endif
+
+#ifndef SE_MANAGE_VOLUME_NAME
+#define SE_MANAGE_VOLUME_NAME "SeManageVolumePrivilege"
+#endif
+
+#ifndef INVALID_SET_FILE_POINTER
+#define INVALID_SET_FILE_POINTER ((DWORD)0xFFFF)
+#endif
+
+#ifndef FSCTL_SET_SPARSE
+#define FSCTL_SET_SPARSE 0x000900c4
+#endif
+
+#ifndef FSCTL_SET_ZERO_DATA
+#define FSCTL_SET_ZERO_DATA 0x000980c8
+#endif
+
+typedef union _LLARGE_INTEGER {
+  struct {
+    DWORD LowPart;
+    LONG  HighPart;
+  } DUMMYSTRUCTNAME;
+  struct {
+    DWORD LowPart;
+    LONG  HighPart;
+  } u;
+  LONGLONG QuadPart;
+} LLARGE_INTEGER;
+
+typedef union _LLARGE_INTEGER * PLLARGE_INTEGER;
+typedef union _LLARGE_INTEGER FAR * LPLLARGE_INTEGER;
+
+typedef struct _LFILE_ZERO_DATA_INFORMATION {
+  LLARGE_INTEGER FileOffset;
+  LLARGE_INTEGER BeyondFinalZero;
+} LFILE_ZERO_DATA_INFORMATION, *PLFILE_ZERO_DATA_INFORMATION;
+
+typedef struct _LFILE_ZERO_DATA_INFORMATION FAR * LPLFILE_ZERO_DATA_INFORMATION;
+
+typedef BOOL (WINAPI *POpenProcessToken)(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
+typedef BOOL (WINAPI FAR *LPOpenProcessToken)(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
+typedef HANDLE (WINAPI *PGetCurrentProcess)();
+typedef HANDLE (WINAPI FAR *LPGetCurrentProcess)();
+
+typedef BOOL (WINAPI *PAdjustTokenPrivileges)(HANDLE TokenHandle, BOOL DisableAllPrivileges, PLTOKEN_PRIVILEGES NewState, DWORD BufferLength, PLTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength);
+typedef BOOL (WINAPI FAR *LPAdjustTokenPrivileges)(HANDLE TokenHandle, BOOL DisableAllPrivileges, PLTOKEN_PRIVILEGES NewState, DWORD BufferLength, PLTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength);
+
+typedef BOOL (WINAPI *PLookupPrivilegeValueA)(LPCSTR lpSystemName, LPCSTR lpName, PLLUID lpLuid);
+typedef BOOL (WINAPI FAR *LPLookupPrivilegeValueA)(LPCSTR lpSystemName, LPCSTR lpName, PLLUID lpLuid);
+
+typedef BOOL (WINAPI *PSetFilePointerEx)(HANDLE hFile, LLARGE_INTEGER liDistanceToMove, PLLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod);
+typedef BOOL (WINAPI FAR *LPSetFilePointerEx)(HANDLE hFile, LLARGE_INTEGER liDistanceToMove, PLLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod);
+
+typedef DWORD (WINAPI *PSetFilePointer)(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
+typedef DWORD (WINAPI FAR *LPSetFilePointer)(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
+
+typedef BOOL (WINAPI *PSetEndOfFile)(HANDLE hFile);
+typedef BOOL (WINAPI FAR *LPSetEndOfFile)(HANDLE hFile);
+
+typedef BOOL (WINAPI * PSetFileValidData)(HANDLE hFile, LONGLONG ValidDataLength);
+typedef BOOL (WINAPI FAR * LPSetFileValidData)(HANDLE hFile, LONGLONG ValidDataLength);
+
+typedef BOOL (WINAPI *PDeviceIoControl)(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
+typedef BOOL (WINAPI FAR *LPDeviceIoControl)(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
+
+class Fallocate
+{
+private:
+	static int instanceCount;
+	static HMODULE hAdvapi32;
+	static HMODULE hKernel32;
+	static FARPROC fpOpenProcessToken;
+	static FARPROC fpGetCurrentProcess;
+	static FARPROC fpLookupPrivilegeValueA;
+	static FARPROC fpAdjustTokenPrivileges;
+	static FARPROC fpSetFilePointerEx;
+	static FARPROC fpSetFilePointer;
+	static FARPROC fpSetEndOfFile;
+	static FARPROC fpSetFileValidData;
+	static FARPROC fpDeviceIoControl;
+
+	static int SetPos(HANDLE hFile, LLARGE_INTEGER liDistanceToMove, PLLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod)
+	{
+		if(fpSetFilePointerEx)
+		{
+			if (!((LPSetFilePointerEx)fpSetFilePointerEx)(hFile, liDistanceToMove, lpNewFilePointer, dwMoveMethod))
+				return EBADF;
+		}
+		else if(fpSetFilePointer)
+		{
+			LONG resHigh = liDistanceToMove.u.HighPart;
+			DWORD resLow = ((LPSetFilePointer)fpSetFilePointer)(hFile, liDistanceToMove.u.LowPart, &resHigh, dwMoveMethod);
+			if (resLow == INVALID_SET_FILE_POINTER)
+				return EBADF;
+
+			if(lpNewFilePointer != NULL)
+			{
+				lpNewFilePointer->u.LowPart = resLow;
+				lpNewFilePointer->u.HighPart = resHigh;
+			}
+		}
+		else
+		{
+			return ENOSYS; // TODO: what now?
+		}
+		
+		return 0;
+	}
+public:
+	Fallocate()
+	{
+		if(instanceCount == 0)
+		{
+			hAdvapi32 = LoadLibrary(TEXT("Advapi32"));
+			hKernel32 = LoadLibrary(TEXT("Kernel32"));
+
+			if(hAdvapi32 != 0)
+			{
+				fpOpenProcessToken = GetProcAddress(hAdvapi32, "OpenProcessToken");
+				fpLookupPrivilegeValueA = GetProcAddress(hAdvapi32, "LookupPrivilegeValueA");
+
+				if(fpLookupPrivilegeValueA == 0)
+				{
+					fpLookupPrivilegeValueA = GetProcAddress(hAdvapi32, "LookupPrivilegeValue");
+				}
+
+				fpAdjustTokenPrivileges = GetProcAddress(hAdvapi32, "AdjustTokenPrivileges");
+			}
+
+			if(hKernel32 != 0)
+			{
+				fpGetCurrentProcess = GetProcAddress(hKernel32, "GetCurrentProcess");
+				fpSetFilePointer = GetProcAddress(hKernel32, "SetFilePointer");
+				fpSetFilePointerEx = GetProcAddress(hKernel32, "SetFilePointerEx");
+				fpSetEndOfFile = GetProcAddress(hKernel32, "SetEndOfFile");
+				fpSetFileValidData = GetProcAddress(hKernel32, "SetFileValidData");
+				fpDeviceIoControl = GetProcAddress(hKernel32, "DeviceIoControl");
+			}
+
+			instanceCount++;
+
+			HANDLE cur_token = NULL;
+			LTOKEN_PRIVILEGES new_tp;
+			LLUID luid;
+			if(fpOpenProcessToken)
+			{          
+				if (!((LPOpenProcessToken)fpOpenProcessToken) (((LPGetCurrentProcess)fpGetCurrentProcess)(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
+					&cur_token))
+				{
+					return;
+				}
+			}
+
+			if(fpLookupPrivilegeValueA)
+			{
+				if (!((LPLookupPrivilegeValueA)fpLookupPrivilegeValueA) (NULL, SE_MANAGE_VOLUME_NAME, &luid))
+				{
+					CloseHandle(cur_token); //I'd have used ON_BLOCK_EXIT, but want to keep dependency count down :)
+					return;
+				}
+			}
+			
+			memset(&new_tp, 0, sizeof(LTOKEN_PRIVILEGES));
+			new_tp.PrivilegeCount = 1;
+			new_tp.Privileges[0].Luid = luid;
+			new_tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
+
+			if(fpAdjustTokenPrivileges)
+			{
+				if (!((LPAdjustTokenPrivileges)fpAdjustTokenPrivileges) (cur_token, FALSE, &new_tp, sizeof(LTOKEN_PRIVILEGES), NULL, NULL))
+				{
+					CloseHandle (cur_token);
+					return;
+				}
+			}
+
+			if(cur_token)
+				CloseHandle(cur_token);
+		}
+	}
+
+	static int fallocate(int fd, off_t offset, off_t len)
+	{
+		DWORD zeroLow = 0;
+		LONG zeroHigh = 0;
+		LLARGE_INTEGER zeroPos;
+		LLARGE_INTEGER oldPos;
+		LLARGE_INTEGER endPos;
+		LLARGE_INTEGER newPos;
+		LLARGE_INTEGER minusOne;
+		static const DWORD DWORD_MAX=0xFFFFFFFF;
+		int setPosRes;
+
+		minusOne.u.HighPart = 0xFFFFFFFF;
+		minusOne.u.LowPart = 0xFFFFFFFF;
+
+		memset(&zeroPos, '\0', sizeof zeroPos);
+
+		#ifndef q4_WCE
+			HANDLE h = (HANDLE) _get_osfhandle(fd);
+		#else
+			HANDLE h = (HANDLE)fd;
+		#endif //q4_WCE
+
+		if(offset < 0 || len < 0)
+		{
+			return EINVAL;
+		}
+
+		// get original position.
+		setPosRes = SetPos(h, zeroPos, &oldPos, FILE_CURRENT);
+		if(setPosRes)
+		{
+			return setPosRes;
+		}
+
+		// get current file end.
+		setPosRes = SetPos(h, zeroPos, &endPos, FILE_END);
+		if(setPosRes)
+		{
+			return setPosRes;
+		}
+
+		// jump to offset.
+		LLARGE_INTEGER tmpPos;
+		tmpPos.u.LowPart = offset;
+		tmpPos.u.HighPart = 0;
+
+		setPosRes = SetPos(h, tmpPos, NULL, FILE_BEGIN);
+		if(setPosRes)
+		{
+			SetPos(h, oldPos, NULL, FILE_BEGIN); // restore position on error.
+			return setPosRes;
+		}
+
+		// jump to length.
+		tmpPos.u.LowPart = len;
+		tmpPos.u.HighPart = 0;
+		
+		setPosRes = SetPos(h, tmpPos, &newPos, FILE_CURRENT);
+		if(setPosRes)
+		{
+			SetPos(h, oldPos, NULL, FILE_BEGIN); // restore position on error.
+			return setPosRes;
+		}
+
+		if(fpSetEndOfFile)
+		{
+			if(endPos.u.HighPart < newPos.u.HighPart
+				|| (endPos.u.HighPart == newPos.u.HighPart && endPos.u.LowPart < newPos.u.LowPart))
+			{
+				if(!((LPSetEndOfFile)fpSetEndOfFile)(h))
+				{
+					SetPos(h, oldPos, NULL, FILE_BEGIN); // restore position on error.
+					return ENOSPC;
+				}
+			}
+		}
+
+		LONGLONG sizeToReserve = newPos.QuadPart - endPos.QuadPart;
+		if(fpSetFileValidData)
+		{
+			if (((LPSetFileValidData)fpSetFileValidData)(h, sizeToReserve)!=0)
+			{
+				SetPos(h, oldPos, NULL, FILE_BEGIN); // restore position on success.
+				return 0; //Success!
+			}
+		}
+
+		if(fpDeviceIoControl)
+		{
+			//Bummer. Can't expand the file this way - now try sparse files	
+			DWORD temp=0;
+			//Mark the file as sparse.
+   			if (((LPDeviceIoControl)fpDeviceIoControl)(h, FSCTL_SET_SPARSE, NULL, 0, NULL, 0,  &temp, NULL)!=0)
+			{				
+				LFILE_ZERO_DATA_INFORMATION range;
+				range.FileOffset.QuadPart = endPos.QuadPart;
+				range.BeyondFinalZero.QuadPart = newPos.QuadPart;
+				//Actually set the sparse range.
+				if (((LPDeviceIoControl)fpDeviceIoControl)(h, FSCTL_SET_ZERO_DATA, &range, sizeof(range), NULL, 0, &temp, NULL))
+				{
+					SetPos(h, oldPos, NULL, FILE_BEGIN); // restore position on success.
+					return 0; //Done
+				}					
+			}
+		}
+
+		setPosRes = SetPos(h, minusOne, &tmpPos, FILE_END);
+		if(setPosRes)
+		{
+			SetPos(h, oldPos, NULL, FILE_BEGIN); // restore position on error.
+			return setPosRes;
+		}
+
+		char initializer_buf [1] = {1};
+		DWORD written=0;
+		if (!WriteFile(h, initializer_buf, 1, &written, NULL))
+		{
+			SetPos(h, oldPos, NULL, FILE_BEGIN); // restore position on error.
+			return ENOSPC;
+		}
+
+		SetPos(h, oldPos, NULL, FILE_BEGIN); // restore position on success.
+		return 0;
+	}
+
+	static int posix_fallocate(int fd, off_t offset, off_t len)
+	{
+		DWORD zeroLow = 0;
+		LONG zeroHigh = 0;
+		LLARGE_INTEGER zeroPos;
+		LLARGE_INTEGER oldPos;
+		LLARGE_INTEGER endPos;
+		LLARGE_INTEGER newPos;
+		LLARGE_INTEGER minusOne;
+		static const DWORD DWORD_MAX=0xFFFFFFFF;
+		int setPosRes;
+
+		minusOne.u.HighPart = 0xFFFFFFFF;
+		minusOne.u.LowPart = 0xFFFFFFFF;
+
+		memset(&zeroPos, '\0', sizeof zeroPos);
+
+		#ifndef q4_WCE
+			HANDLE h = (HANDLE) _get_osfhandle(fd);
+		#else
+			HANDLE h = (HANDLE)fd;
+		#endif //q4_WCE
+
+		if(offset < 0 || len < 0)
+		{
+			return EINVAL;
+		}
+
+		// get original position.
+		setPosRes = SetPos(h, zeroPos, &oldPos, FILE_CURRENT);
+		if(setPosRes)
+		{
+			return setPosRes;
+		}
+
+		// get current file end.
+		setPosRes = SetPos(h, zeroPos, &endPos, FILE_END);
+		if(setPosRes)
+		{
+			return setPosRes;
+		}
+
+		// jump to offset.
+		LLARGE_INTEGER tmpPos;
+		tmpPos.u.LowPart = offset;
+		tmpPos.u.HighPart = 0;
+
+		setPosRes = SetPos(h, tmpPos, NULL, FILE_BEGIN);
+		if(setPosRes)
+		{
+			SetPos(h, oldPos, NULL, FILE_BEGIN); // restore position on error.
+			return setPosRes;
+		}
+
+		// jump to length.
+		tmpPos.u.LowPart = len;
+		tmpPos.u.HighPart = 0;
+		
+		setPosRes = SetPos(h, tmpPos, &newPos, FILE_CURRENT);
+		if(setPosRes)
+		{
+			SetPos(h, oldPos, NULL, FILE_BEGIN); // restore position on error.
+			return setPosRes;
+		}
+
+		if(fpSetEndOfFile)
+		{
+			if(endPos.u.HighPart < newPos.u.HighPart
+				|| (endPos.u.HighPart == newPos.u.HighPart && endPos.u.LowPart < newPos.u.LowPart))
+			{
+				if(!((LPSetEndOfFile)fpSetEndOfFile)(h))
+				{
+					SetPos(h, oldPos, NULL, FILE_BEGIN); // restore position on error.
+					return ENOSPC;
+				}
+			}
+		}
+
+		setPosRes = SetPos(h, minusOne, &tmpPos, FILE_END);
+		if(setPosRes)
+		{
+			SetPos(h, oldPos, NULL, FILE_BEGIN); // restore position on error.
+			return setPosRes;
+		}
+
+		char initializer_buf [1] = {1};
+		DWORD written=0;
+		if (!WriteFile(h, initializer_buf, 1, &written, NULL))
+		{
+			SetPos(h, oldPos, NULL, FILE_BEGIN); // restore position on error.
+			return ENOSPC;
+		}
+
+		SetPos(h, oldPos, NULL, FILE_BEGIN); // restore position on success.
+		return 0;
+	}
+
+	~Fallocate()
+	{
+		if(instanceCount > 0)
+		{
+			instanceCount--;
+
+			if(instanceCount == 0)
+			{
+				fpOpenProcessToken = NULL;
+				fpLookupPrivilegeValueA = NULL;
+				fpGetCurrentProcess = NULL;
+				fpAdjustTokenPrivileges = NULL;
+				fpSetFilePointer = NULL;
+				fpSetFilePointerEx = NULL;
+				fpSetEndOfFile = NULL;
+				fpSetFileValidData = NULL;
+				fpDeviceIoControl = NULL;
+
+				if(hKernel32 != 0)
+				{
+					FreeLibrary(hKernel32);
+					hKernel32 = 0;
+				}
+
+				if(hAdvapi32 != 0)
+				{
+					FreeLibrary(hAdvapi32);
+					hAdvapi32 = 0;
+				}
+			}
+		}
+	}
+};
+
+int Fallocate::instanceCount = 0;
+HMODULE Fallocate::hAdvapi32 = 0;
+HMODULE Fallocate::hKernel32 = 0;
+FARPROC Fallocate::fpOpenProcessToken = NULL;
+FARPROC Fallocate::fpLookupPrivilegeValueA = NULL;
+FARPROC Fallocate::fpGetCurrentProcess = NULL;
+FARPROC Fallocate::fpAdjustTokenPrivileges = NULL;
+FARPROC Fallocate::fpSetFilePointer = NULL;
+FARPROC Fallocate::fpSetFilePointerEx = NULL;
+FARPROC Fallocate::fpSetEndOfFile = NULL;
+FARPROC Fallocate::fpSetFileValidData = NULL;
+FARPROC Fallocate::fpDeviceIoControl = NULL;
+
+static Fallocate _fallocate;
+
+int posix_fallocate(int fd, off_t offset, off_t len)
+{
+	return Fallocate::posix_fallocate(fd, offset, len);
+}
+
diff -Naur Retro68.old/libelf/src/fallocate.h Retro68/libelf/src/fallocate.h
--- Retro68.old/libelf/src/fallocate.h	1969-12-31 16:00:00.000000000 -0800
+++ Retro68/libelf/src/fallocate.h	2020-05-09 20:17:08.339125206 -0700
@@ -0,0 +1,7 @@
+#ifndef FALLOCATE_H
+#define FALLOCATE_H
+
+//typedef LONG off_t;
+
+int posix_fallocate(int fd, off_t offset, off_t len);
+#endif
diff -Naur Retro68.old/libelf/src/fchmod.cpp Retro68/libelf/src/fchmod.cpp
--- Retro68.old/libelf/src/fchmod.cpp	1969-12-31 16:00:00.000000000 -0800
+++ Retro68/libelf/src/fchmod.cpp	2020-05-05 21:58:06.612681066 -0700
@@ -0,0 +1,1164 @@
+#include "fchmod.h"
+
+#include <windows.h>
+#include <tchar.h>
+#include <stdio.h>
+#include <io.h>
+#include <wchar.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <errno.h>
+//#include <winternl.h>
+
+// NT structures are undefined outside NT DDKs
+typedef enum _OBJECT_INFORMATION_CLASS {
+    ObjectBasicInformation,
+    ObjectNameInformation,
+    ObjectTypeInformation,
+    ObjectAllInformation,
+    ObjectDataInformation
+} OBJECT_INFORMATION_CLASS, *POBJECT_INFORMATION_CLASS;
+
+typedef enum _OBJECT_INFORMATION_CLASS FAR* LPOBJECT_INFORMATION_CLASS;
+
+typedef struct _UNICODE_STRING {
+  USHORT Length;
+  USHORT MaximumLength;
+  PWSTR  Buffer;
+} UNICODE_STRING, *PUNICODE_STRING;
+
+typedef struct _UNICODE_STRING FAR * LPUNICODE_STRING;
+
+typedef struct _PUBLIC_OBJECT_BASIC_INFORMATION {
+    ULONG Attributes;
+    ACCESS_MASK GrantedAccess;
+    ULONG HandleCount;
+    ULONG PointerCount;
+    ULONG Reserved[10];    // reserved for internal use
+ } PUBLIC_OBJECT_BASIC_INFORMATION, *PPUBLIC_OBJECT_BASIC_INFORMATION;
+
+typedef struct _PUBLIC_OBJECT_BASIC_INFORMATION FAR *LPPUBLIC_OBJECT_BASIC_INFORMATION;
+
+typedef struct __PUBLIC_OBJECT_TYPE_INFORMATION {
+    UNICODE_STRING TypeName;
+    ULONG Reserved [22];    // reserved for internal use
+} PUBLIC_OBJECT_TYPE_INFORMATION, *PPUBLIC_OBJECT_TYPE_INFORMATION;
+
+typedef struct __PUBLIC_OBJECT_TYPE_INFORMATION FAR *LPPUBLIC_OBJECT_TYPE_INFORMATION;
+
+typedef struct _OBJECT_NAME_INFORMATION {
+    UNICODE_STRING Name;
+} OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;
+
+typedef struct _OBJECT_NAME_INFORMATION FAR *LPOBJECT_NAME_INFORMATION;
+
+// NSTATUS codes are undefined outside NT DDKs
+#ifndef STATUS_SUCCESS
+#define STATUS_SUCCESS                   ((NTSTATUS) 0x00000000)
+#endif
+
+#ifndef STATUS_BUFFER_OVERFLOW
+#define STATUS_BUFFER_OVERFLOW           ((NTSTATUS) 0x80000005)
+#endif
+
+#ifndef STATUS_INFO_LENGTH_MISMATCH
+#define STATUS_INFO_LENGTH_MISMATCH      ((NTSTATUS) 0xC0000004)
+#endif
+
+#ifndef MIN
+#define MIN(A, B) (((A) < (B)) ? (A) : (B))
+#endif
+
+#ifndef VOLUME_NAME_DOS
+#define VOLUME_NAME_DOS 0x0
+#endif
+
+#ifndef VOLUME_NAME_GUID
+#define VOLUME_NAME_GUID 0x1
+#endif
+
+#ifndef VOLUME_NAME_NONE
+#define VOLUME_NAME_NONE 0x4
+#endif
+
+#ifndef VOLUME_NAME_NT
+#define VOLUME_NAME_NT 0x2
+#endif
+
+#ifndef FILE_NAME_NORMALIZED
+#define FILE_NAME_NORMALIZED 0x0
+#endif
+
+#ifndef FILE_NAME_OPENED
+#define FILE_NAME_OPENED 0x8
+#endif
+
+// CompareString and CompareStringW are undefined on NT 3.1
+#ifndef CompareString
+	#ifdef  UNICODE
+		#define CompareString CompareStringW
+	#else   /* UNICODE */
+		#define CompareString CompareStringA
+	#endif /* UNICODE */
+	static inline int CompareStringA(LCID lcid, DWORD fdwStyle, LPCSTR lpString1, int cch1, LPCSTR lpString2, int cch2)
+	{
+		int lpString1Len = ((lpString1 == NULL) ? 0 : lstrlen(lpString1));
+		int lpString2Len = ((lpString2 == NULL) ? 0 : lstrlen(lpString2));
+
+		int cch1BufLength;
+		int cch2BufLength;
+
+		int i;
+		int ret;
+
+		LPWSTR string1;
+		LPWSTR string2;
+
+		if(cch1 < 0)
+		{
+			cch1BufLength = lpString1Len;
+		}
+		else
+		{
+			cch1BufLength = MIN(lpString1Len + 1, cch1);
+		}
+
+		if(cch2 < 0)
+		{
+			cch2BufLength = lpString2Len;
+		}
+		else
+		{
+			cch2BufLength = MIN(lpString2Len + 1, cch2);
+		}
+
+		string1 = (LPWSTR)LocalAlloc(LPTR, cch1BufLength * sizeof (WCHAR));
+
+		if(string1 == NULL)
+		{
+			return 0;
+		}
+
+		string2 = (LPWSTR)LocalAlloc(LPTR, cch2BufLength * sizeof (WCHAR));
+
+		if(string2 == NULL)
+		{
+			DWORD err = GetLastError();
+			LocalFree(string1);
+			SetLastError(err);
+
+			return 0;
+		}
+
+		for(i = 0; i < cch1BufLength; i++)
+		{
+			string1[i] = lpString1[i];
+		}
+
+		for(i = 0; i < cch2BufLength; i++)
+		{
+			string2[i] = lpString2[i];
+		}
+
+		ret = CompareStringW(lcid, fdwStyle, string1, cch1, string2, cch2);
+
+		LocalFree(string1);
+		LocalFree(string2);
+
+		return ret;
+	}
+#endif
+
+// CSTR_EQUAL is undefined in NT 3.1 SDK
+#ifndef CSTR_EQUAL
+#define CSTR_EQUAL 2
+#endif
+
+typedef DWORD (WINAPI * PGetFinalPathNameByHandleW)(HANDLE hFile, LPWSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags);
+typedef DWORD (WINAPI * PGetFinalPathNameByHandleA)(HANDLE hFile, LPSTR  lpszFilePath, DWORD  cchFilePath, DWORD  dwFlags);
+typedef DWORD (WINAPI * PGetFinalPathNameByHandleT)(HANDLE hFile, LPTSTR  lpszFilePath, DWORD  cchFilePath, DWORD  dwFlags);
+
+typedef DWORD (WINAPI FAR * LPGetFinalPathNameByHandleW)(HANDLE hFile, LPWSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags);
+typedef DWORD (WINAPI FAR * LPGetFinalPathNameByHandleA)(HANDLE hFile, LPSTR  lpszFilePath, DWORD  cchFilePath, DWORD  dwFlags);
+typedef DWORD (WINAPI FAR * LPGetFinalPathNameByHandleT)(HANDLE hFile, LPTSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags);
+
+typedef LONG NTSTATUS;
+typedef NTSTATUS (WINAPI * PNtQueryObject)(HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength);
+typedef NTSTATUS (WINAPI FAR * LPNtQueryObject)(HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength);
+
+typedef DWORD (WINAPI * PGetMappedFileNameA)(HANDLE hProcess, LPVOID lpv, LPSTR lpFilename, DWORD nSize);
+typedef DWORD (WINAPI * PGetMappedFileNameW)(HANDLE hProcess, LPVOID lpv, LPWSTR lpFilename, DWORD nSize);
+typedef DWORD (WINAPI * PGetMappedFileNameT)(HANDLE hProcess, LPVOID lpv, LPTSTR lpFilename, DWORD nSize);
+
+typedef DWORD (WINAPI FAR * LPGetMappedFileNameA)(HANDLE hProcess, LPVOID lpv, LPSTR lpFilename, DWORD nSize);
+typedef DWORD (WINAPI FAR * LPGetMappedFileNameW)(HANDLE hProcess, LPVOID lpv, LPWSTR lpFilename, DWORD nSize);
+typedef DWORD (WINAPI FAR * LPGetMappedFileNameT)(HANDLE hProcess, LPVOID lpv, LPTSTR lpFilename, DWORD nSize);
+
+class GetWindowsFchmodFuncs
+{
+	private: 
+		static int numInstances;
+		static HMODULE hKernel32;
+		static HMODULE hNtDll;
+		static HMODULE hPsapi;
+		static FARPROC fpGetFinalPathNameByHandleA;
+		static FARPROC fpGetFinalPathNameByHandleW;
+		static FARPROC fpGetFinalPathNameByHandleT;
+		static FARPROC fpGetMappedFileNameA;
+		static FARPROC fpGetMappedFileNameW;
+		static FARPROC fpGetMappedFileNameT;
+		static FARPROC fpNtQueryObject;
+
+	// converts
+	// "\Device\HarddiskVolume3"                                -> "E:"
+	// "\Device\HarddiskVolume3\Temp"                           -> "E:\Temp"
+	// "\Device\HarddiskVolume3\Temp\transparent.jpeg"          -> "E:\Temp\transparent.jpeg"
+	// "\Device\Harddisk1\DP(1)0-0+6\foto.jpg"                  -> "I:\foto.jpg"
+	// "\Device\TrueCryptVolumeP\Data\Passwords.txt"            -> "P:\Data\Passwords.txt"
+	// "\Device\Floppy0\Autoexec.bat"                           -> "A:\Autoexec.bat"
+	// "\Device\CdRom1\VIDEO_TS\VTS_01_0.VOB"                   -> "H:\VIDEO_TS\VTS_01_0.VOB"
+	// "\Device\Serial1"                                        -> "COM1"
+	// "\Device\USBSER000"                                      -> "COM4"
+	// "\Device\Mup\ComputerName\C$\Boot.ini"                   -> "\\ComputerName\C$\Boot.ini"
+	// "\Device\LanmanRedirector\ComputerName\C$\Boot.ini"      -> "\\ComputerName\C$\Boot.ini"
+	// "\Device\LanmanRedirector\ComputerName\Shares\Dance.m3u" -> "\\ComputerName\Shares\Dance.m3u"
+	// returns an error for any other device type
+	static DWORD GetTDosPathFromNtPath(LPCTSTR u16_NTPath, LPTSTR* ps_DosPath)
+	{
+		DWORD u32_Error;
+
+		*ps_DosPath = NULL;
+		size_t bufLen = 1;
+
+		if (CompareString(GetThreadLocale(), NORM_IGNORECASE, u16_NTPath, 14, TEXT("\\Device\\Serial"), 14) == CSTR_EQUAL || // e.g. "Serial1"
+			CompareString(GetThreadLocale(), NORM_IGNORECASE, u16_NTPath, 14, TEXT("\\Device\\UsbSer"), 14) == CSTR_EQUAL)   // e.g. "USBSER000"
+		//if (_tcsnicmp(u16_NTPath, TEXT("\\Device\\Serial"), 14) == 0 || // e.g. "Serial1"
+		//	_tcsnicmp(u16_NTPath, TEXT("\\Device\\UsbSer"), 14) == 0)   // e.g. "USBSER000"
+		{
+			HKEY h_Key; 
+			if (u32_Error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Hardware\\DeviceMap\\SerialComm"), 0, KEY_QUERY_VALUE, &h_Key))
+				return u32_Error;
+
+			BYTE u16_ComPort[50];
+
+			DWORD u32_Type;
+			DWORD u32_Size = sizeof(u16_ComPort); 
+			if (u32_Error = RegQueryValueEx(h_Key, (LPTSTR)u16_NTPath, 0, &u32_Type, u16_ComPort, &u32_Size))
+			{
+				RegCloseKey(h_Key);
+				return ERROR_UNKNOWN_PORT;
+			}
+
+			bufLen += lstrlen((TCHAR *)u16_ComPort);
+			if(*ps_DosPath == NULL)
+			{
+				*ps_DosPath = (LPTSTR)LocalAlloc(LPTR, bufLen * sizeof (TCHAR));
+				lstrcpy(*ps_DosPath, TEXT(""));
+			}
+			else
+			{
+				*ps_DosPath = (LPTSTR)LocalReAlloc((HANDLE)*ps_DosPath, bufLen * sizeof (TCHAR), LMEM_ZEROINIT);
+			}
+			lstrcat(*ps_DosPath, (TCHAR *)(u16_ComPort));
+			RegCloseKey(h_Key);
+			return 0;
+		}
+
+		if (CompareString(GetThreadLocale(), NORM_IGNORECASE, u16_NTPath, 25, TEXT("\\Device\\LanmanRedirector\\"), 25) == CSTR_EQUAL) // Win XP
+		//if (_tcsnicmp(u16_NTPath, TEXT("\\Device\\LanmanRedirector\\"), 25) == 0) // Win XP
+		{
+			bufLen += lstrlen(TEXT("\\\\"));
+			bufLen += lstrlen((u16_NTPath + 25));
+
+			if(*ps_DosPath == NULL)
+			{
+				*ps_DosPath = (LPTSTR)LocalAlloc(LPTR, bufLen * sizeof (TCHAR));
+				lstrcpy(*ps_DosPath, TEXT(""));
+			}
+			else
+			{
+				*ps_DosPath = (LPTSTR)LocalReAlloc((HANDLE)*ps_DosPath, bufLen * sizeof (TCHAR), LMEM_ZEROINIT);
+			}
+			lstrcat(*ps_DosPath, TEXT("\\\\"));
+			lstrcat(*ps_DosPath, (u16_NTPath + 25));
+			return 0;
+		}
+
+		if (CompareString(GetThreadLocale(), NORM_IGNORECASE, u16_NTPath, 12, TEXT("\\Device\\Mup\\"), 12) == CSTR_EQUAL) // Win 7
+		//if (_tcsnicmp(u16_NTPath, TEXT("\\Device\\Mup\\"), 12) == 0) // Win 7
+		{
+			bufLen += lstrlen(TEXT("\\\\"));
+			bufLen += lstrlen((u16_NTPath + 12));
+			if(*ps_DosPath == NULL)
+			{
+				*ps_DosPath = (LPTSTR)LocalAlloc(LPTR, bufLen * sizeof (TCHAR));
+				lstrcpy(*ps_DosPath, TEXT(""));
+			}
+			else
+			{
+				*ps_DosPath = (LPTSTR)LocalReAlloc((HANDLE)*ps_DosPath, bufLen * sizeof (TCHAR), LMEM_ZEROINIT);
+			}
+			lstrcat(*ps_DosPath, TEXT("\\\\"));
+			lstrcat(*ps_DosPath, (u16_NTPath + 12));
+			return 0;
+		}
+
+		TCHAR u16_Drives[300];
+		if (!GetLogicalDriveStrings(300, u16_Drives))
+			return GetLastError();
+
+		TCHAR* u16_Drv = u16_Drives;
+		while (u16_Drv[0])
+		{
+			TCHAR* u16_Next = u16_Drv + lstrlen(u16_Drv) + 1;
+			u16_Drv[2] = 0; // the backslash is not allowed for QueryDosDevice()
+
+			TCHAR u16_NtVolume[1000];
+			u16_NtVolume[0] = 0;
+
+			// may return multiple strings!
+			// returns very weird strings for network shares
+			if (!QueryDosDevice(u16_Drv, u16_NtVolume, sizeof(u16_NtVolume) / sizeof u16_NtVolume[0]))
+				return GetLastError();
+
+			int s32_Len = (int)lstrlen(u16_NtVolume);
+			if (s32_Len > 0 && CompareString(GetThreadLocale(), NORM_IGNORECASE, u16_NtVolume, s32_Len, u16_NTPath, s32_Len) == CSTR_EQUAL)
+			//if (s32_Len > 0 && _tcsnicmp(u16_NTPath, u16_NtVolume, s32_Len) == 0)
+			{
+				bufLen += lstrlen(u16_Drv);
+				bufLen += lstrlen((u16_NTPath + s32_Len));
+				if(*ps_DosPath == NULL)
+				{
+					*ps_DosPath = (LPTSTR)LocalAlloc(LPTR, bufLen * sizeof (TCHAR));
+					lstrcpy(*ps_DosPath, TEXT(""));
+				}
+				else
+				{
+					*ps_DosPath = (LPTSTR)LocalReAlloc((HANDLE)*ps_DosPath, bufLen * sizeof (TCHAR), LMEM_ZEROINIT);
+				}
+				lstrcat(*ps_DosPath, u16_Drv);
+				lstrcat(*ps_DosPath, (u16_NTPath + s32_Len));
+				return 0;
+			}
+
+			u16_Drv = u16_Next;
+		}
+		return ERROR_BAD_PATHNAME;
+	}
+
+	static DWORD GetWDosPathFromNtPath(LPCWSTR u16_NTPath, LPWSTR* ps_DosPath)
+	{
+		DWORD u32_Error;
+
+		*ps_DosPath = NULL;
+		size_t bufLen = 1;
+
+		if (CompareStringW(GetThreadLocale(), NORM_IGNORECASE, u16_NTPath, 14, L"\\Device\\Serial", 14) == CSTR_EQUAL || // e.g. "Serial1"
+			CompareStringW(GetThreadLocale(), NORM_IGNORECASE, u16_NTPath, 14, L"\\Device\\UsbSer", 14) == CSTR_EQUAL)   // e.g. "USBSER000"
+		//if (_tcsnicmp(u16_NTPath, TEXT("\\Device\\Serial"), 14) == 0 || // e.g. "Serial1"
+		//	_tcsnicmp(u16_NTPath, TEXT("\\Device\\UsbSer"), 14) == 0)   // e.g. "USBSER000"
+		{
+			HKEY h_Key; 
+			if (u32_Error = RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"Hardware\\DeviceMap\\SerialComm", 0, KEY_QUERY_VALUE, &h_Key))
+				return u32_Error;
+
+			BYTE u16_ComPort[50];
+
+			DWORD u32_Type;
+			DWORD u32_Size = sizeof(u16_ComPort); 
+			if (u32_Error = RegQueryValueExW(h_Key, (LPWSTR)u16_NTPath, 0, &u32_Type, u16_ComPort, &u32_Size))
+			{
+				RegCloseKey(h_Key);
+				return ERROR_UNKNOWN_PORT;
+			}
+
+			bufLen += lstrlenW((WCHAR *)u16_ComPort);
+			if(*ps_DosPath == NULL)
+			{
+				*ps_DosPath = (LPWSTR)LocalAlloc(LPTR, bufLen * sizeof (WCHAR));
+				lstrcpyW(*ps_DosPath, L"");
+			}
+			else
+			{
+				*ps_DosPath = (LPWSTR)LocalReAlloc((HANDLE)*ps_DosPath, bufLen * sizeof (WCHAR), LMEM_ZEROINIT);
+			}
+			lstrcatW(*ps_DosPath, (WCHAR *)(u16_ComPort));
+			RegCloseKey(h_Key);
+			return 0;
+		}
+
+		if (CompareStringW(GetThreadLocale(), NORM_IGNORECASE, u16_NTPath, 25, L"\\Device\\LanmanRedirector\\", 25) == CSTR_EQUAL) // Win XP
+		//if (_tcsnicmp(u16_NTPath, TEXT("\\Device\\LanmanRedirector\\"), 25) == 0) // Win XP
+		{
+			bufLen += lstrlenW(L"\\\\");
+			bufLen += lstrlenW((u16_NTPath + 25));
+
+			if(*ps_DosPath == NULL)
+			{
+				*ps_DosPath = (LPWSTR)LocalAlloc(LPTR, bufLen * sizeof (WCHAR));
+				lstrcpyW(*ps_DosPath, L"");
+			}
+			else
+			{
+				*ps_DosPath = (LPWSTR)LocalReAlloc((HANDLE)*ps_DosPath, bufLen * sizeof (WCHAR), LMEM_ZEROINIT);
+			}
+			lstrcatW(*ps_DosPath, L"\\\\");
+			lstrcatW(*ps_DosPath, (u16_NTPath + 25));
+			return 0;
+		}
+
+		if (CompareStringW(GetThreadLocale(), NORM_IGNORECASE, u16_NTPath, 12, L"\\Device\\Mup\\", 12) == CSTR_EQUAL) // Win 7
+		//if (_tcsnicmp(u16_NTPath, TEXT("\\Device\\Mup\\"), 12) == 0) // Win 7
+		{
+			bufLen += lstrlenW(L"\\\\");
+			bufLen += lstrlenW((u16_NTPath + 12));
+			if(*ps_DosPath == NULL)
+			{
+				*ps_DosPath = (LPWSTR)LocalAlloc(LPTR, bufLen * sizeof (WCHAR));
+				lstrcpyW(*ps_DosPath, L"");
+			}
+			else
+			{
+				*ps_DosPath = (LPWSTR)LocalReAlloc((HANDLE)*ps_DosPath, bufLen * sizeof (WCHAR), LMEM_ZEROINIT);
+			}
+			lstrcatW(*ps_DosPath, L"\\\\");
+			lstrcatW(*ps_DosPath, (u16_NTPath + 12));
+			return 0;
+		}
+
+		WCHAR u16_Drives[300];
+		if (!GetLogicalDriveStringsW(300, u16_Drives))
+			return GetLastError();
+
+		WCHAR* u16_Drv = u16_Drives;
+		while (u16_Drv[0])
+		{
+			WCHAR* u16_Next = u16_Drv + lstrlenW(u16_Drv) + 1;
+			u16_Drv[2] = 0; // the backslash is not allowed for QueryDosDevice()
+
+			WCHAR u16_NtVolume[1000];
+			u16_NtVolume[0] = 0;
+
+			// may return multiple strings!
+			// returns very weird strings for network shares
+			if (!QueryDosDeviceW(u16_Drv, u16_NtVolume, sizeof(u16_NtVolume) / sizeof u16_NtVolume[0]))
+				return GetLastError();
+
+			int s32_Len = (int)lstrlenW(u16_NtVolume);
+			if (s32_Len > 0 && CompareStringW(GetThreadLocale(), NORM_IGNORECASE, u16_NtVolume, s32_Len, u16_NTPath, s32_Len) == CSTR_EQUAL)
+			//if (s32_Len > 0 && _tcsnicmp(u16_NTPath, u16_NtVolume, s32_Len) == 0)
+			{
+				bufLen += lstrlenW(u16_Drv);
+				bufLen += lstrlenW((u16_NTPath + s32_Len));
+				if(*ps_DosPath == NULL)
+				{
+					*ps_DosPath = (LPWSTR)LocalAlloc(LPTR, bufLen * sizeof (WCHAR));
+					lstrcpyW(*ps_DosPath, L"");
+				}
+				else
+				{
+					*ps_DosPath = (LPWSTR)LocalReAlloc((HANDLE)*ps_DosPath, bufLen * sizeof (WCHAR), LMEM_ZEROINIT);
+				}
+				lstrcatW(*ps_DosPath, u16_Drv);
+				lstrcatW(*ps_DosPath, (u16_NTPath + s32_Len));
+				return 0;
+			}
+
+			u16_Drv = u16_Next;
+		}
+		return ERROR_BAD_PATHNAME;
+	}
+
+	static DWORD GetADosPathFromNtPath(LPCSTR u16_NTPath, LPSTR* ps_DosPath)
+	{
+		DWORD u32_Error;
+
+		*ps_DosPath = NULL;
+		size_t bufLen = 1;
+
+		if (CompareStringA(GetThreadLocale(), NORM_IGNORECASE, u16_NTPath, 14, "\\Device\\Serial", 14) == CSTR_EQUAL || // e.g. "Serial1"
+			CompareStringA(GetThreadLocale(), NORM_IGNORECASE, u16_NTPath, 14, "\\Device\\UsbSer", 14) == CSTR_EQUAL)   // e.g. "USBSER000"
+		//if (_tcsnicmp(u16_NTPath, "\\Device\\Serial", 14) == 0 || // e.g. "Serial1"
+		//	_tcsnicmp(u16_NTPath, "\\Device\\UsbSer", 14) == 0)   // e.g. "USBSER000"
+		{
+			HKEY h_Key; 
+			if (u32_Error = RegOpenKeyExA(HKEY_LOCAL_MACHINE, "Hardware\\DeviceMap\\SerialComm", 0, KEY_QUERY_VALUE, &h_Key))
+				return u32_Error;
+
+			BYTE u16_ComPort[50];
+
+			DWORD u32_Type;
+			DWORD u32_Size = sizeof(u16_ComPort); 
+			if (u32_Error = RegQueryValueExA(h_Key, (LPSTR)u16_NTPath, 0, &u32_Type, u16_ComPort, &u32_Size))
+			{
+				RegCloseKey(h_Key);
+				return ERROR_UNKNOWN_PORT;
+			}
+
+			bufLen += lstrlenA((CHAR *)u16_ComPort);
+			if(*ps_DosPath == NULL)
+			{
+				*ps_DosPath = (LPSTR)LocalAlloc(LPTR, bufLen * sizeof (CHAR));
+				lstrcpyA(*ps_DosPath, "");
+			}
+			else
+			{
+				*ps_DosPath = (LPSTR)LocalReAlloc((HANDLE)*ps_DosPath, bufLen * sizeof (CHAR), LMEM_ZEROINIT);
+			}
+			lstrcatA(*ps_DosPath, (CHAR *)(u16_ComPort));
+			RegCloseKey(h_Key);
+			return 0;
+		}
+
+		if (CompareStringA(GetThreadLocale(), NORM_IGNORECASE, u16_NTPath, 25, "\\Device\\LanmanRedirector\\", 25) == CSTR_EQUAL) // Win XP
+		//if (_tcsnicmp(u16_NTPath, "\\Device\\LanmanRedirector\\", 25) == 0) // Win XP
+		{
+			bufLen += lstrlenA("\\\\");
+			bufLen += lstrlenA((u16_NTPath + 25));
+
+			if(*ps_DosPath == NULL)
+			{
+				*ps_DosPath = (LPSTR)LocalAlloc(LPTR, bufLen * sizeof (CHAR));
+				lstrcpyA(*ps_DosPath, "");
+			}
+			else
+			{
+				*ps_DosPath = (LPSTR)LocalReAlloc((HANDLE)*ps_DosPath, bufLen * sizeof (CHAR), LMEM_ZEROINIT);
+			}
+			lstrcatA(*ps_DosPath, "\\\\");
+			lstrcatA(*ps_DosPath, (u16_NTPath + 25));
+			return 0;
+		}
+
+		if (CompareStringA(GetThreadLocale(), NORM_IGNORECASE, u16_NTPath, 12, "\\Device\\Mup\\", 12) == CSTR_EQUAL) // Win 7
+		//if (_tcsnicmp(u16_NTPath, "\\Device\\Mup\\", 12) == 0) // Win 7
+		{
+			bufLen += lstrlenA("\\\\");
+			bufLen += lstrlenA((u16_NTPath + 12));
+			if(*ps_DosPath == NULL)
+			{
+				*ps_DosPath = (LPSTR)LocalAlloc(LPTR, bufLen * sizeof (CHAR));
+				lstrcpyA(*ps_DosPath, "");
+			}
+			else
+			{
+				*ps_DosPath = (LPSTR)LocalReAlloc((HANDLE)*ps_DosPath, bufLen * sizeof (CHAR), LMEM_ZEROINIT);
+			}
+			lstrcatA(*ps_DosPath, "\\\\");
+			lstrcatA(*ps_DosPath, (u16_NTPath + 12));
+			return 0;
+		}
+
+		CHAR u16_Drives[300];
+		if (!GetLogicalDriveStringsA(300, u16_Drives))
+			return GetLastError();
+
+		CHAR* u16_Drv = u16_Drives;
+		while (u16_Drv[0])
+		{
+			CHAR* u16_Next = u16_Drv + lstrlenA(u16_Drv) + 1;
+			u16_Drv[2] = 0; // the backslash is not allowed for QueryDosDevice()
+
+			CHAR u16_NtVolume[1000];
+			u16_NtVolume[0] = 0;
+
+			// may return multiple strings!
+			// returns very weird strings for network shares
+			if (!QueryDosDeviceA(u16_Drv, u16_NtVolume, sizeof(u16_NtVolume) / sizeof u16_NtVolume[0]))
+				return GetLastError();
+
+			int s32_Len = (int)lstrlenA(u16_NtVolume);
+			if (s32_Len > 0 && CompareStringA(GetThreadLocale(), NORM_IGNORECASE, u16_NtVolume, s32_Len, u16_NTPath, s32_Len) == CSTR_EQUAL)
+			//if (s32_Len > 0 && _tcsnicmp(u16_NTPath, u16_NtVolume, s32_Len) == 0)
+			{
+				bufLen += lstrlenA(u16_Drv);
+				bufLen += lstrlenA((u16_NTPath + s32_Len));
+				if(*ps_DosPath == NULL)
+				{
+					*ps_DosPath = (LPSTR)LocalAlloc(LPTR, bufLen * sizeof (CHAR));
+					lstrcpyA(*ps_DosPath, "");
+				}
+				else
+				{
+					*ps_DosPath = (LPSTR)LocalReAlloc((HANDLE)*ps_DosPath, bufLen * sizeof (CHAR), LMEM_ZEROINIT);
+				}
+				lstrcatA(*ps_DosPath, u16_Drv);
+				lstrcatA(*ps_DosPath, (u16_NTPath + s32_Len));
+				return 0;
+			}
+
+			u16_Drv = u16_Next;
+		}
+		return ERROR_BAD_PATHNAME;
+	}
+
+	public:
+
+		GetWindowsFchmodFuncs()
+		{
+			if(numInstances == 0)
+			{
+				hNtDll = LoadLibrary(TEXT("NTDLL"));
+				hKernel32 = LoadLibrary(TEXT("KERNEL32"));
+				hPsapi = LoadLibrary(TEXT("PSAPI"));
+
+				if(hNtDll != 0)
+				{
+					fpNtQueryObject = GetProcAddress(hNtDll, "NtQueryObject");
+				}
+
+				if(hKernel32 != 0)
+				{
+					fpGetFinalPathNameByHandleA = GetProcAddress(hKernel32, "GetFinalPathNameByHandleA");
+					fpGetFinalPathNameByHandleW = GetProcAddress(hKernel32, "GetFinalPathNameByHandleW");
+
+					if(fpGetFinalPathNameByHandleA == NULL)
+					{
+						fpGetFinalPathNameByHandleA = GetProcAddress(hKernel32, "GetFinalPathNameByHandle");
+					}
+
+					#ifdef  UNICODE
+						fpGetFinalPathNameByHandleT = fpGetFinalPathNameByHandleW;
+					#else   /* UNICODE */
+						fpGetFinalPathNameByHandleT = fpGetFinalPathNameByHandleA;
+					#endif /* UNICODE */
+
+					fpGetMappedFileNameA = GetProcAddress(hKernel32, "GetMappedFileNameA");
+
+					if(fpGetMappedFileNameA == NULL)
+					{
+						fpGetMappedFileNameA = GetProcAddress(hKernel32, "K32GetMappedFileNameA");
+
+						if(fpGetMappedFileNameA == NULL)
+						{
+							fpGetMappedFileNameA = GetProcAddress(hKernel32, "GetMappedFileName");
+
+							if(fpGetMappedFileNameA == NULL)
+							{
+								fpGetMappedFileNameA = GetProcAddress(hKernel32, "K32GetMappedFileName");
+							}
+						}
+					}
+
+					fpGetMappedFileNameW = GetProcAddress(hKernel32, "GetMappedFileNameW");
+
+					if(fpGetMappedFileNameW == NULL)
+					{
+						fpGetMappedFileNameW = GetProcAddress(hKernel32, "K32GetMappedFileNameW");
+					}
+
+					#ifdef  UNICODE
+						fpGetMappedFileNameT = fpGetMappedFileNameW;
+					#else   /* UNICODE */
+						fpGetMappedFileNameT = fpGetMappedFileNameA;
+					#endif /* UNICODE */
+				}
+
+				if(hPsapi != NULL && fpGetMappedFileNameA == NULL && fpGetMappedFileNameW == NULL)
+				{
+					fpGetMappedFileNameA = GetProcAddress(hPsapi, "GetMappedFileNameA");
+
+					if(fpGetMappedFileNameA == NULL)
+					{
+						fpGetMappedFileNameA = GetProcAddress(hPsapi, "K32GetMappedFileNameA");
+
+						if(fpGetMappedFileNameA == NULL)
+						{
+							fpGetMappedFileNameA = GetProcAddress(hPsapi, "GetMappedFileName");
+
+							if(fpGetMappedFileNameA == NULL)
+							{
+								fpGetMappedFileNameA = GetProcAddress(hPsapi, "K32GetMappedFileName");
+							}
+						}
+					}
+
+					fpGetMappedFileNameW = GetProcAddress(hPsapi, "GetMappedFileNameW");
+
+					if(fpGetMappedFileNameW == NULL)
+					{
+						fpGetMappedFileNameW = GetProcAddress(hPsapi, "K32GetMappedFileNameW");
+					}
+
+					#ifdef  UNICODE
+						fpGetMappedFileNameT = fpGetMappedFileNameW;
+					#else   /* UNICODE */
+						fpGetMappedFileNameT = fpGetMappedFileNameA;
+					#endif /* UNICODE */
+				}
+			}
+			numInstances++;
+		}
+
+		~GetWindowsFchmodFuncs()
+		{
+			numInstances--;
+			if(numInstances == 0)
+			{
+				if(hPsapi != 0)
+				{
+					FreeLibrary(hPsapi);
+					hPsapi = 0;
+				}
+
+				if(hNtDll != 0)
+				{
+					FreeLibrary(hNtDll);
+					hNtDll = 0;
+				}
+
+				if(hKernel32 != 0)
+				{
+					FreeLibrary(hKernel32);
+					hKernel32 = 0;
+				}
+				
+				fpGetFinalPathNameByHandleA = NULL;
+				fpGetFinalPathNameByHandleW = NULL;
+			}
+		}
+
+		static LPCSTR GetAPathByHandle(int fd)
+		{
+			LPSTR name = NULL;
+
+			#ifndef q4_WCE
+				HANDLE h = (HANDLE) _get_osfhandle(fd);
+			#else
+				HANDLE h = (HANDLE)fd;
+			#endif //q4_WCE
+
+			if(fpGetFinalPathNameByHandleA)
+			{
+				DWORD bufSize = 0;
+				CHAR t;
+				LPSTR ntPath = NULL;
+
+				bufSize = ((LPGetFinalPathNameByHandleA)fpGetFinalPathNameByHandleA)(h, &t, 0, FILE_NAME_NORMALIZED | VOLUME_NAME_NT);
+				if(bufSize == 0)
+				{
+					return NULL;
+				}
+				else
+				{
+					ntPath = (LPSTR)LocalAlloc(LPTR, (bufSize + 1) * sizeof (CHAR));
+
+					if(ntPath == 0)
+					{
+						return NULL;
+					}
+					else
+					{
+						if(((LPGetFinalPathNameByHandleA)fpGetFinalPathNameByHandleA)(h, ntPath, (bufSize + 1), FILE_NAME_NORMALIZED | VOLUME_NAME_NT) == 0)
+						{
+							LocalFree(ntPath);
+							return NULL;
+						}
+						else
+						{
+							if(GetADosPathFromNtPath(ntPath, &name) != 0)
+							{
+								if(name != NULL)
+								{
+									LocalFree(name);
+									name = NULL;
+								}
+							}
+							LocalFree((HANDLE)ntPath);
+						}
+					}
+				}
+			}
+			else if(fpNtQueryObject)
+			{
+				BYTE buf[sizeof (OBJECT_NAME_INFORMATION) / sizeof (BYTE) + MAX_PATH * sizeof (WCHAR) / sizeof (BYTE) + sizeof (WCHAR) / sizeof (BYTE)];
+				size_t bufSize = sizeof buf / sizeof buf[0];
+
+				ULONG returnLength;
+				NTSTATUS ret = ((LPNtQueryObject)fpNtQueryObject)(h, ObjectNameInformation, buf, bufSize, &returnLength);
+
+				if(ret == STATUS_SUCCESS)
+				{
+					int i;
+					POBJECT_NAME_INFORMATION info = (POBJECT_NAME_INFORMATION)buf;
+					LPSTR ntPath = NULL;
+
+					ntPath = (LPSTR)LocalAlloc(LPTR, (info->Name.Length + 1) * sizeof (CHAR));
+					if(ntPath != NULL)
+					{
+						for(i = 0; i < info->Name.Length; i++)
+						{
+							ntPath[i] = (char)(info->Name.Buffer[i] & 0xFF);
+						}
+
+						if(GetADosPathFromNtPath(ntPath, &name) != 0)
+						{
+							if(name != NULL)
+							{
+								LocalFree(name);
+								name = NULL;
+							}
+						}
+						LocalFree((HANDLE)ntPath);
+						ntPath = NULL;
+					}
+				}
+			}
+			else if(fpGetMappedFileNameA != NULL)
+			{
+				DWORD dwFileSizeHi = 0;
+				DWORD dwFileSizeLo = GetFileSize(h, &dwFileSizeHi);
+				HANDLE hFileMap = 0;
+
+				if(dwFileSizeLo == 0 && dwFileSizeHi == 0)
+				{
+					return NULL;
+				}
+
+				hFileMap = CreateFileMapping(h, NULL, PAGE_READONLY, 0, 1, NULL);
+
+				if(hFileMap == NULL)
+				{
+					DWORD errNo = GetLastError();
+					return NULL;
+				}
+
+				LPVOID pMem = MapViewOfFile(hFileMap, FILE_MAP_READ, 0, 0, 1);
+
+				if(pMem == NULL)
+				{
+					CloseHandle(hFileMap);
+					return NULL;
+				}
+
+				CHAR pszFilename[MAX_PATH+1];
+
+				if(((LPGetMappedFileNameA)fpGetMappedFileNameA)(GetCurrentProcess(), pMem, pszFilename, MAX_PATH))
+				{
+					if(GetADosPathFromNtPath(pszFilename, &name) != 0)
+					{
+						if(name != NULL)
+						{
+							LocalFree(name);
+							name = NULL;
+						}
+					}
+				}
+
+				UnmapViewOfFile(pMem);
+				CloseHandle(hFileMap);
+			}
+
+			return name;
+		}
+
+		static WCHAR* GetWPathByHandle(int fd)
+		{
+			LPWSTR name = NULL;
+
+			#ifndef q4_WCE
+				HANDLE h = (HANDLE) _get_osfhandle(fd);
+			#else
+				HANDLE h = (HANDLE)fd;
+			#endif //q4_WCE
+
+			if(fpGetFinalPathNameByHandleW)
+			{
+				DWORD bufSize = 0;
+				WCHAR t;
+				LPWSTR ntPath = NULL;
+
+				bufSize = ((LPGetFinalPathNameByHandleW)fpGetFinalPathNameByHandleW)(h, &t, 0, FILE_NAME_NORMALIZED | VOLUME_NAME_NT);
+				if(bufSize == 0)
+				{
+					return NULL;
+				}
+				else
+				{
+					ntPath = (LPWSTR)LocalAlloc(LPTR, (bufSize + 1) * sizeof (WCHAR));
+
+					if(ntPath == 0)
+					{
+						return NULL;
+					}
+					else
+					{
+						if(((LPGetFinalPathNameByHandleW)fpGetFinalPathNameByHandleW)(h, ntPath, (bufSize + 1), FILE_NAME_NORMALIZED | VOLUME_NAME_NT) == 0)
+						{
+							LocalFree(ntPath);
+							return NULL;
+						}
+						else
+						{
+							if(GetWDosPathFromNtPath(ntPath, &name) != 0)
+							{
+								if(name != NULL)
+								{
+									LocalFree(name);
+									name = NULL;
+								}
+							}
+							LocalFree((HANDLE)ntPath);
+						}
+					}
+				}
+			}
+			else if(fpNtQueryObject)
+			{
+				BYTE buf[sizeof (OBJECT_NAME_INFORMATION) / sizeof (BYTE) + MAX_PATH * sizeof (WCHAR) / sizeof (BYTE) + sizeof (WCHAR) / sizeof (BYTE)];
+				size_t bufSize = sizeof buf / sizeof buf[0];
+
+				ULONG returnLength;
+				NTSTATUS ret = ((LPNtQueryObject)fpNtQueryObject)(h, ObjectNameInformation, buf, bufSize, &returnLength);
+
+				if(ret == STATUS_SUCCESS)
+				{
+					POBJECT_NAME_INFORMATION info = (POBJECT_NAME_INFORMATION)buf;
+					LPWSTR ntPath = NULL;
+
+					ntPath = (LPWSTR)LocalAlloc(LPTR, (info->Name.Length + 1) * sizeof (WCHAR));
+					if(ntPath != NULL)
+					{
+						lstrcpyW(ntPath, info->Name.Buffer);
+
+						if(GetWDosPathFromNtPath(ntPath, &name) != 0)
+						{
+							if(name != NULL)
+							{
+								LocalFree(name);
+								name = NULL;
+							}
+						}
+						LocalFree((HANDLE)ntPath);
+						ntPath = NULL;
+					}
+				}
+			}
+			else if(fpGetMappedFileNameW != NULL)
+			{
+				DWORD dwFileSizeHi = 0;
+				DWORD dwFileSizeLo = GetFileSize(h, &dwFileSizeHi);
+				HANDLE hFileMap = 0;
+
+				if(dwFileSizeLo == 0 && dwFileSizeHi == 0)
+				{
+					return NULL;
+				}
+
+				hFileMap = CreateFileMapping(h, NULL, PAGE_READONLY, 0, 1, NULL);
+
+				if(hFileMap == NULL)
+				{
+					DWORD errNo = GetLastError();
+					return NULL;
+				}
+
+				LPVOID pMem = MapViewOfFile(hFileMap, FILE_MAP_READ, 0, 0, 1);
+
+				if(pMem == NULL)
+				{
+					CloseHandle(hFileMap);
+					return NULL;
+				}
+
+				WCHAR pszFilename[MAX_PATH+1];
+
+				if(((LPGetMappedFileNameW)fpGetMappedFileNameW)(GetCurrentProcess(), pMem, pszFilename, MAX_PATH))
+				{
+					if(GetWDosPathFromNtPath(pszFilename, &name) != 0)
+					{
+						if(name != NULL)
+						{
+							LocalFree(name);
+							name = NULL;
+						}
+					}
+				}
+
+				UnmapViewOfFile(pMem);
+				CloseHandle(hFileMap);
+			}
+
+			return name;
+		}
+
+		static LPCTSTR GetTPathByHandle(int fd)
+		{
+			LPTSTR name = NULL;
+
+			#ifndef q4_WCE
+				HANDLE h = (HANDLE) _get_osfhandle(fd);
+			#else
+				HANDLE h = (HANDLE)fd;
+			#endif //q4_WCE
+
+			if(fpGetFinalPathNameByHandleT)
+			{
+				DWORD bufSize = 0;
+				TCHAR t;
+				LPTSTR ntPath = NULL;
+
+				bufSize = ((LPGetFinalPathNameByHandleT)fpGetFinalPathNameByHandleT)(h, &t, 0, FILE_NAME_NORMALIZED | VOLUME_NAME_NT);
+				if(bufSize == 0)
+				{
+					return NULL;
+				}
+				else
+				{
+					ntPath = (LPTSTR)LocalAlloc(LPTR, (bufSize + 1) * sizeof (TCHAR));
+
+					if(ntPath == 0)
+					{
+						return NULL;
+					}
+					else
+					{
+						if(((LPGetFinalPathNameByHandleT)fpGetFinalPathNameByHandleT)(h, ntPath, (bufSize + 1), FILE_NAME_NORMALIZED | VOLUME_NAME_NT) == 0)
+						{
+							LocalFree(ntPath);
+							return NULL;
+						}
+						else
+						{
+							if(GetTDosPathFromNtPath(ntPath, &name) != 0)
+							{
+								if(name != NULL)
+								{
+									LocalFree(name);
+									name = NULL;
+								}
+							}
+							LocalFree((HANDLE)ntPath);
+						}
+					}
+				}
+			}
+			else if(fpNtQueryObject)
+			{
+				BYTE buf[sizeof (OBJECT_NAME_INFORMATION) / sizeof (BYTE) + MAX_PATH * sizeof (WCHAR) / sizeof (BYTE) + sizeof (WCHAR) / sizeof (BYTE)];
+				size_t bufSize = sizeof buf / sizeof buf[0];
+
+				ULONG returnLength;
+				NTSTATUS ret = ((LPNtQueryObject)fpNtQueryObject)(h, ObjectNameInformation, buf, bufSize, &returnLength);
+
+				if(ret == STATUS_SUCCESS)
+				{
+					int i;
+					POBJECT_NAME_INFORMATION info = (POBJECT_NAME_INFORMATION)buf;
+					LPTSTR ntPath = NULL;
+
+					ntPath = (LPTSTR)LocalAlloc(LPTR, (info->Name.Length + 1) * sizeof (TCHAR));
+					if(ntPath != NULL)
+					{
+						#ifdef  UNICODE
+						lstrcpyW(ntPath, info->Name.Buffer);
+						#else
+						for(i = 0; i < info->Name.Length; i++)
+						{
+							ntPath[i] = (char)(info->Name.Buffer[i] & 0xFF);
+						}
+						#endif /* UNICODE */
+
+						if(GetTDosPathFromNtPath(ntPath, &name) != 0)
+						{
+							if(name != NULL)
+							{
+								LocalFree(name);
+								name = NULL;
+							}
+						}
+						LocalFree((HANDLE)ntPath);
+						ntPath = NULL;
+					}
+				}
+			}
+			else if(fpGetMappedFileNameT != NULL)
+			{
+				DWORD dwFileSizeHi = 0;
+				DWORD dwFileSizeLo = GetFileSize(h, &dwFileSizeHi);
+				HANDLE hFileMap = 0;
+
+				if(dwFileSizeLo == 0 && dwFileSizeHi == 0)
+				{
+					return NULL;
+				}
+
+				hFileMap = CreateFileMapping(h, NULL, PAGE_READONLY, 0, 1, NULL);
+
+				if(hFileMap == NULL)
+				{
+					DWORD errNo = GetLastError();
+					return NULL;
+				}
+
+				LPVOID pMem = MapViewOfFile(hFileMap, FILE_MAP_READ, 0, 0, 1);
+
+				if(pMem == NULL)
+				{
+					CloseHandle(hFileMap);
+					return NULL;
+				}
+
+				TCHAR pszFilename[MAX_PATH+1];
+
+				if(((LPGetMappedFileNameT)fpGetMappedFileNameT)(GetCurrentProcess(), pMem, pszFilename, MAX_PATH))
+				{
+					if(GetTDosPathFromNtPath(pszFilename, &name) != 0)
+					{
+						if(name != NULL)
+						{
+							LocalFree(name);
+							name = NULL;
+						}
+					}
+				}
+
+				UnmapViewOfFile(pMem);
+				CloseHandle(hFileMap);
+			}
+
+			return name;
+		}
+};
+
+int GetWindowsFchmodFuncs::numInstances = 0;
+HMODULE GetWindowsFchmodFuncs::hKernel32 = 0;
+HMODULE GetWindowsFchmodFuncs::hNtDll = 0;
+HMODULE GetWindowsFchmodFuncs::hPsapi = 0;
+FARPROC GetWindowsFchmodFuncs::fpGetFinalPathNameByHandleA = NULL;
+FARPROC GetWindowsFchmodFuncs::fpGetFinalPathNameByHandleW = NULL;
+FARPROC GetWindowsFchmodFuncs::fpGetFinalPathNameByHandleT = NULL;
+FARPROC GetWindowsFchmodFuncs::fpGetMappedFileNameA = NULL;
+FARPROC GetWindowsFchmodFuncs::fpGetMappedFileNameW = NULL;
+FARPROC GetWindowsFchmodFuncs::fpGetMappedFileNameT = NULL;
+FARPROC GetWindowsFchmodFuncs::fpNtQueryObject = NULL;
+
+static GetWindowsFchmodFuncs _getWindowsFchmodFuncs;
+
+int fchmod(int fd, int mode)
+{
+	// we don't support other flags, pretend to succeed.
+	if((mode & ~(_S_IREAD | _S_IWRITE)) == mode)
+	{
+		return 0;
+	}
+	else
+	{
+		LPCWSTR filePath = GetWindowsFchmodFuncs::GetWPathByHandle(fd);
+		
+		if(filePath == NULL)
+		{
+			errno = ENOENT;
+			return -1;
+		}
+		else
+		{
+			int ret = _wchmod(filePath, mode);
+			
+			LocalFree((HANDLE)filePath);
+			
+			return ret;
+		}
+	}
+}
+
diff -Naur Retro68.old/libelf/src/fchmod.h Retro68/libelf/src/fchmod.h
--- Retro68.old/libelf/src/fchmod.h	1969-12-31 16:00:00.000000000 -0800
+++ Retro68/libelf/src/fchmod.h	2020-05-05 21:58:45.564752501 -0700
@@ -0,0 +1,14 @@
+#ifndef FCHMOD_H
+#define FCHMOD_H
+
+#ifndef S_ISUID
+#define S_ISUID 04000
+#endif /* S_ISUID */
+
+#ifndef S_ISGID
+#define S_ISGID 02000
+#endif /* S_ISGID */
+
+int fchmod(int fd, int mode);
+
+#endif
diff -Naur Retro68.old/libelf/src/fcntl.c Retro68/libelf/src/fcntl.c
--- Retro68.old/libelf/src/fcntl.c	1969-12-31 16:00:00.000000000 -0800
+++ Retro68/libelf/src/fcntl.c	2020-05-01 20:58:36.312074693 -0700
@@ -0,0 +1,626 @@
+/* Provide file descriptor control.
+
+   Copyright (C) 2009-2018 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* Written by Eric Blake <ebb9@byu.net>.  */
+
+#include <config.h>
+
+/* Specification.  */
+#include <fcntl.h>
+
+#include <errno.h>
+#include <limits.h>
+#include <stdarg.h>
+#include <unistd.h>
+
+#ifdef __KLIBC__
+# define INCL_DOS
+# include <os2.h>
+#endif
+
+#if defined _WIN32 && ! defined __CYGWIN__
+/* Get declarations of the native Windows API functions.  */
+# define WIN32_LEAN_AND_MEAN
+# include <windows.h>
+
+/* Get _get_osfhandle.  */
+# if GNULIB_MSVC_NOTHROW
+#  include "msvc-nothrow.h"
+# else
+#  include <io.h>
+# endif
+
+/* Upper bound on getdtablesize().  See lib/getdtablesize.c.  */
+# define OPEN_MAX_MAX 0x10000
+
+/* Duplicate OLDFD into the first available slot of at least NEWFD,
+   which must be positive, with FLAGS determining whether the duplicate
+   will be inheritable.  */
+static int
+dupfd (int oldfd, int newfd, int flags)
+{
+  /* Mingw has no way to create an arbitrary fd.  Iterate until all
+     file descriptors less than newfd are filled up.  */
+  HANDLE curr_process = GetCurrentProcess ();
+  HANDLE old_handle = (HANDLE) _get_osfhandle (oldfd);
+  unsigned char fds_to_close[OPEN_MAX_MAX / CHAR_BIT];
+  unsigned int fds_to_close_bound = 0;
+  int result;
+  BOOL inherit = flags & O_CLOEXEC ? FALSE : TRUE;
+  int mode;
+
+  if (newfd < 0 || getdtablesize () <= newfd)
+    {
+      errno = EINVAL;
+      return -1;
+    }
+  if (old_handle == INVALID_HANDLE_VALUE
+      || (mode = setmode (oldfd, O_BINARY)) == -1)
+    {
+      /* oldfd is not open, or is an unassigned standard file
+         descriptor.  */
+      errno = EBADF;
+      return -1;
+    }
+  setmode (oldfd, mode);
+  flags |= mode;
+
+  for (;;)
+    {
+      HANDLE new_handle;
+      int duplicated_fd;
+      unsigned int index;
+
+      if (!DuplicateHandle (curr_process,           /* SourceProcessHandle */
+                            old_handle,             /* SourceHandle */
+                            curr_process,           /* TargetProcessHandle */
+                            (PHANDLE) &new_handle,  /* TargetHandle */
+                            (DWORD) 0,              /* DesiredAccess */
+                            inherit,                /* InheritHandle */
+                            DUPLICATE_SAME_ACCESS)) /* Options */
+        {
+          switch (GetLastError ())
+            {
+              case ERROR_TOO_MANY_OPEN_FILES:
+                errno = EMFILE;
+                break;
+              case ERROR_INVALID_HANDLE:
+              case ERROR_INVALID_TARGET_HANDLE:
+              case ERROR_DIRECT_ACCESS_HANDLE:
+                errno = EBADF;
+                break;
+              case ERROR_INVALID_PARAMETER:
+              case ERROR_INVALID_FUNCTION:
+              case ERROR_INVALID_ACCESS:
+                errno = EINVAL;
+                break;
+              default:
+                errno = EACCES;
+                break;
+            }
+          result = -1;
+          break;
+        }
+      duplicated_fd = _open_osfhandle ((intptr_t) new_handle, flags);
+      if (duplicated_fd < 0)
+        {
+          CloseHandle (new_handle);
+          result = -1;
+          break;
+        }
+      if (newfd <= duplicated_fd)
+        {
+          result = duplicated_fd;
+          break;
+        }
+
+      /* Set the bit duplicated_fd in fds_to_close[].  */
+      index = (unsigned int) duplicated_fd / CHAR_BIT;
+      if (fds_to_close_bound <= index)
+        {
+          if (sizeof fds_to_close <= index)
+            /* Need to increase OPEN_MAX_MAX.  */
+            abort ();
+          memset (fds_to_close + fds_to_close_bound, '\0',
+                  index + 1 - fds_to_close_bound);
+          fds_to_close_bound = index + 1;
+        }
+      fds_to_close[index] |= 1 << ((unsigned int) duplicated_fd % CHAR_BIT);
+    }
+
+  /* Close the previous fds that turned out to be too small.  */
+  {
+    int saved_errno = errno;
+    unsigned int duplicated_fd;
+
+    for (duplicated_fd = 0;
+         duplicated_fd < fds_to_close_bound * CHAR_BIT;
+         duplicated_fd++)
+      if ((fds_to_close[duplicated_fd / CHAR_BIT]
+           >> (duplicated_fd % CHAR_BIT))
+          & 1)
+        close (duplicated_fd);
+
+    errno = saved_errno;
+  }
+
+# if REPLACE_FCHDIR
+  if (0 <= result)
+    result = _gl_register_dup (oldfd, result);
+# endif
+  return result;
+}
+#endif /* W32 */
+
+/* Forward declarations, because we '#undef fcntl' in the middle of this
+   compilation unit.  */
+/* Our implementation of fcntl (fd, F_DUPFD, target).  */
+static int rpl_fcntl_DUPFD (int fd, int target);
+/* Our implementation of fcntl (fd, F_DUPFD_CLOEXEC, target).  */
+static int rpl_fcntl_DUPFD_CLOEXEC (int fd, int target);
+#ifdef __KLIBC__
+/* Adds support for fcntl on directories.  */
+static int klibc_fcntl (int fd, int action, /* arg */...);
+#endif
+
+
+/* Perform the specified ACTION on the file descriptor FD, possibly
+   using the argument ARG further described below.  This replacement
+   handles the following actions, and forwards all others on to the
+   native fcntl.  An unrecognized ACTION returns -1 with errno set to
+   EINVAL.
+
+   F_DUPFD - duplicate FD, with int ARG being the minimum target fd.
+   If successful, return the duplicate, which will be inheritable;
+   otherwise return -1 and set errno.
+
+   F_DUPFD_CLOEXEC - duplicate FD, with int ARG being the minimum
+   target fd.  If successful, return the duplicate, which will not be
+   inheritable; otherwise return -1 and set errno.
+
+   F_GETFD - ARG need not be present.  If successful, return a
+   non-negative value containing the descriptor flags of FD (only
+   FD_CLOEXEC is portable, but other flags may be present); otherwise
+   return -1 and set errno.  */
+
+int
+fcntl (int fd, int action, /* arg */...)
+#undef fcntl
+#ifdef __KLIBC__
+# define fcntl klibc_fcntl
+#endif
+{
+  va_list arg;
+  int result = -1;
+  va_start (arg, action);
+  switch (action)
+    {
+    case F_DUPFD:
+      {
+        int target = va_arg (arg, int);
+        result = rpl_fcntl_DUPFD (fd, target);
+        break;
+      }
+
+    case F_DUPFD_CLOEXEC:
+      {
+        int target = va_arg (arg, int);
+        result = rpl_fcntl_DUPFD_CLOEXEC (fd, target);
+        break;
+      }
+
+#if !HAVE_FCNTL
+    case F_GETFD:
+      {
+# if defined _WIN32 && ! defined __CYGWIN__
+        HANDLE handle = (HANDLE) _get_osfhandle (fd);
+        DWORD flags;
+        if (handle == INVALID_HANDLE_VALUE
+            || GetHandleInformation (handle, &flags) == 0)
+          errno = EBADF;
+        else
+          result = (flags & HANDLE_FLAG_INHERIT) ? 0 : FD_CLOEXEC;
+# else /* !W32 */
+        /* Use dup2 to reject invalid file descriptors.  No way to
+           access this information, so punt.  */
+        if (0 <= dup2 (fd, fd))
+          result = 0;
+# endif /* !W32 */
+        break;
+      } /* F_GETFD */
+#endif /* !HAVE_FCNTL */
+
+      /* Implementing F_SETFD on mingw is not trivial - there is no
+         API for changing the O_NOINHERIT bit on an fd, and merely
+         changing the HANDLE_FLAG_INHERIT bit on the underlying handle
+         can lead to odd state.  It may be possible by duplicating the
+         handle, using _open_osfhandle with the right flags, then
+         using dup2 to move the duplicate onto the original, but that
+         is not supported for now.  */
+
+    default:
+      {
+#if HAVE_FCNTL
+        switch (action)
+          {
+          #ifdef F_BARRIERFSYNC                  /* macOS */
+          case F_BARRIERFSYNC:
+          #endif
+          #ifdef F_CHKCLEAN                      /* macOS */
+          case F_CHKCLEAN:
+          #endif
+          #ifdef F_CLOSEM                        /* NetBSD, HP-UX */
+          case F_CLOSEM:
+          #endif
+          #ifdef F_FLUSH_DATA                    /* macOS */
+          case F_FLUSH_DATA:
+          #endif
+          #ifdef F_FREEZE_FS                     /* macOS */
+          case F_FREEZE_FS:
+          #endif
+          #ifdef F_FULLFSYNC                     /* macOS */
+          case F_FULLFSYNC:
+          #endif
+          #ifdef F_GETCONFINED                   /* macOS */
+          case F_GETCONFINED:
+          #endif
+          #ifdef F_GETDEFAULTPROTLEVEL           /* macOS */
+          case F_GETDEFAULTPROTLEVEL:
+          #endif
+          #ifdef F_GETFD                         /* POSIX */
+          case F_GETFD:
+          #endif
+          #ifdef F_GETFL                         /* POSIX */
+          case F_GETFL:
+          #endif
+          #ifdef F_GETLEASE                      /* Linux */
+          case F_GETLEASE:
+          #endif
+          #ifdef F_GETNOSIGPIPE                  /* macOS */
+          case F_GETNOSIGPIPE:
+          #endif
+          #ifdef F_GETOWN                        /* POSIX */
+          case F_GETOWN:
+          #endif
+          #ifdef F_GETPIPE_SZ                    /* Linux */
+          case F_GETPIPE_SZ:
+          #endif
+          #ifdef F_GETPROTECTIONCLASS            /* macOS */
+          case F_GETPROTECTIONCLASS:
+          #endif
+          #ifdef F_GETPROTECTIONLEVEL            /* macOS */
+          case F_GETPROTECTIONLEVEL:
+          #endif
+          #ifdef F_GET_SEALS                     /* Linux */
+          case F_GET_SEALS:
+          #endif
+          #ifdef F_GETSIG                        /* Linux */
+          case F_GETSIG:
+          #endif
+          #ifdef F_MAXFD                         /* NetBSD */
+          case F_MAXFD:
+          #endif
+          #ifdef F_RECYCLE                       /* macOS */
+          case F_RECYCLE:
+          #endif
+          #ifdef F_SETFIFOENH                    /* HP-UX */
+          case F_SETFIFOENH:
+          #endif
+          #ifdef F_THAW_FS                       /* macOS */
+          case F_THAW_FS:
+          #endif
+            /* These actions take no argument.  */
+            result = fcntl (fd, action);
+            break;
+
+          #ifdef F_ADD_SEALS                     /* Linux */
+          case F_ADD_SEALS:
+          #endif
+          #ifdef F_BADFD                         /* Solaris */
+          case F_BADFD:
+          #endif
+          #ifdef F_CHECK_OPENEVT                 /* macOS */
+          case F_CHECK_OPENEVT:
+          #endif
+          #ifdef F_DUP2FD                        /* FreeBSD, AIX, Solaris */
+          case F_DUP2FD:
+          #endif
+          #ifdef F_DUP2FD_CLOEXEC                /* FreeBSD, Solaris */
+          case F_DUP2FD_CLOEXEC:
+          #endif
+          #ifdef F_DUP2FD_CLOFORK                /* Solaris */
+          case F_DUP2FD_CLOFORK:
+          #endif
+          #ifdef F_DUPFD                         /* POSIX */
+          case F_DUPFD:
+          #endif
+          #ifdef F_DUPFD_CLOEXEC                 /* POSIX */
+          case F_DUPFD_CLOEXEC:
+          #endif
+          #ifdef F_DUPFD_CLOFORK                 /* Solaris */
+          case F_DUPFD_CLOFORK:
+          #endif
+          #ifdef F_GETXFL                        /* Solaris */
+          case F_GETXFL:
+          #endif
+          #ifdef F_GLOBAL_NOCACHE                /* macOS */
+          case F_GLOBAL_NOCACHE:
+          #endif
+          #ifdef F_MAKECOMPRESSED                /* macOS */
+          case F_MAKECOMPRESSED:
+          #endif
+          #ifdef F_MOVEDATAEXTENTS               /* macOS */
+          case F_MOVEDATAEXTENTS:
+          #endif
+          #ifdef F_NOCACHE                       /* macOS */
+          case F_NOCACHE:
+          #endif
+          #ifdef F_NODIRECT                      /* macOS */
+          case F_NODIRECT:
+          #endif
+          #ifdef F_NOTIFY                        /* Linux */
+          case F_NOTIFY:
+          #endif
+          #ifdef F_OPLKACK                       /* IRIX */
+          case F_OPLKACK:
+          #endif
+          #ifdef F_OPLKREG                       /* IRIX */
+          case F_OPLKREG:
+          #endif
+          #ifdef F_RDAHEAD                       /* macOS */
+          case F_RDAHEAD:
+          #endif
+          #ifdef F_SETBACKINGSTORE               /* macOS */
+          case F_SETBACKINGSTORE:
+          #endif
+          #ifdef F_SETCONFINED                   /* macOS */
+          case F_SETCONFINED:
+          #endif
+          #ifdef F_SETFD                         /* POSIX */
+          case F_SETFD:
+          #endif
+          #ifdef F_SETFL                         /* POSIX */
+          case F_SETFL:
+          #endif
+          #ifdef F_SETLEASE                      /* Linux */
+          case F_SETLEASE:
+          #endif
+          #ifdef F_SETNOSIGPIPE                  /* macOS */
+          case F_SETNOSIGPIPE:
+          #endif
+          #ifdef F_SETOWN                        /* POSIX */
+          case F_SETOWN:
+          #endif
+          #ifdef F_SETPIPE_SZ                    /* Linux */
+          case F_SETPIPE_SZ:
+          #endif
+          #ifdef F_SETPROTECTIONCLASS            /* macOS */
+          case F_SETPROTECTIONCLASS:
+          #endif
+          #ifdef F_SETSIG                        /* Linux */
+          case F_SETSIG:
+          #endif
+          #ifdef F_SINGLE_WRITER                 /* macOS */
+          case F_SINGLE_WRITER:
+          #endif
+            /* These actions take an 'int' argument.  */
+            {
+              int x = va_arg (arg, int);
+              result = fcntl (fd, action, x);
+            }
+            break;
+
+          default:
+            /* Other actions take a pointer argument.  */
+            {
+              void *p = va_arg (arg, void *);
+              result = fcntl (fd, action, p);
+            }
+            break;
+          }
+#else
+        errno = EINVAL;
+#endif
+        break;
+      }
+    }
+  va_end (arg);
+  return result;
+}
+
+static int
+rpl_fcntl_DUPFD (int fd, int target)
+{
+  int result;
+#if !HAVE_FCNTL
+  result = dupfd (fd, target, 0);
+#elif FCNTL_DUPFD_BUGGY || REPLACE_FCHDIR
+  /* Detect invalid target; needed for cygwin 1.5.x.  */
+  if (target < 0 || getdtablesize () <= target)
+    {
+      result = -1;
+      errno = EINVAL;
+    }
+  else
+    {
+      /* Haiku alpha 2 loses fd flags on original.  */
+      int flags = fcntl (fd, F_GETFD);
+      if (flags < 0)
+        result = -1;
+      else
+        {
+          result = fcntl (fd, F_DUPFD, target);
+          if (0 <= result && fcntl (fd, F_SETFD, flags) == -1)
+            {
+              int saved_errno = errno;
+              close (result);
+              result = -1;
+              errno = saved_errno;
+            }
+# if REPLACE_FCHDIR
+          if (0 <= result)
+            result = _gl_register_dup (fd, result);
+# endif
+        }
+    }
+#else
+  result = fcntl (fd, F_DUPFD, target);
+#endif
+  return result;
+}
+
+static int
+rpl_fcntl_DUPFD_CLOEXEC (int fd, int target)
+{
+  int result;
+#if !HAVE_FCNTL
+  result = dupfd (fd, target, O_CLOEXEC);
+#else /* HAVE_FCNTL */
+# if defined __HAIKU__
+  /* On Haiku, the system fcntl (fd, F_DUPFD_CLOEXEC, target) sets
+     the FD_CLOEXEC flag on fd, not on target.  Therefore avoid the
+     system fcntl in this case.  */
+#  define have_dupfd_cloexec -1
+# else
+  /* Try the system call first, if the headers claim it exists
+     (that is, if GNULIB_defined_F_DUPFD_CLOEXEC is 0), since we
+     may be running with a glibc that has the macro but with an
+     older kernel that does not support it.  Cache the
+     information on whether the system call really works, but
+     avoid caching failure if the corresponding F_DUPFD fails
+     for any reason.  0 = unknown, 1 = yes, -1 = no.  */
+  static int have_dupfd_cloexec = GNULIB_defined_F_DUPFD_CLOEXEC ? -1 : 0;
+  if (0 <= have_dupfd_cloexec)
+    {
+      result = fcntl (fd, F_DUPFD_CLOEXEC, target);
+      if (0 <= result || errno != EINVAL)
+        {
+          have_dupfd_cloexec = 1;
+#  if REPLACE_FCHDIR
+          if (0 <= result)
+            result = _gl_register_dup (fd, result);
+#  endif
+        }
+      else
+        {
+          result = rpl_fcntl_DUPFD (fd, target);
+          if (result >= 0)
+            have_dupfd_cloexec = -1;
+        }
+    }
+  else
+# endif
+    result = rpl_fcntl_DUPFD (fd, target);
+  if (0 <= result && have_dupfd_cloexec == -1)
+    {
+      int flags = fcntl (result, F_GETFD);
+      if (flags < 0 || fcntl (result, F_SETFD, flags | FD_CLOEXEC) == -1)
+        {
+          int saved_errno = errno;
+          close (result);
+          errno = saved_errno;
+          result = -1;
+        }
+    }
+#endif /* HAVE_FCNTL */
+  return result;
+}
+
+#undef fcntl
+
+#ifdef __KLIBC__
+
+static int
+klibc_fcntl (int fd, int action, /* arg */...);
+{
+  va_list arg_ptr;
+  int arg;
+  struct stat sbuf;
+  int result;
+
+  va_start (arg_ptr, action);
+  arg = va_arg (arg_ptr, int);
+  result = fcntl (fd, action, arg);
+  /* EPERM for F_DUPFD, ENOTSUP for others */
+  if (result == -1 && (errno == EPERM || errno == ENOTSUP)
+      && !fstat (fd, &sbuf) && S_ISDIR (sbuf.st_mode))
+    {
+      ULONG ulMode;
+
+      switch (action)
+        {
+        case F_DUPFD:
+          /* Find available fd */
+          while (fcntl (arg, F_GETFL) != -1 || errno != EBADF)
+            arg++;
+
+          result = dup2 (fd, arg);
+          break;
+
+        /* Using underlying APIs is right ? */
+        case F_GETFD:
+          if (DosQueryFHState (fd, &ulMode))
+            break;
+
+          result = (ulMode & OPEN_FLAGS_NOINHERIT) ? FD_CLOEXEC : 0;
+          break;
+
+        case F_SETFD:
+          if (arg & ~FD_CLOEXEC)
+            break;
+
+          if (DosQueryFHState (fd, &ulMode))
+            break;
+
+          if (arg & FD_CLOEXEC)
+            ulMode |= OPEN_FLAGS_NOINHERIT;
+          else
+            ulMode &= ~OPEN_FLAGS_NOINHERIT;
+
+          /* Filter supported flags.  */
+          ulMode &= (OPEN_FLAGS_WRITE_THROUGH | OPEN_FLAGS_FAIL_ON_ERROR
+                     | OPEN_FLAGS_NO_CACHE | OPEN_FLAGS_NOINHERIT);
+
+          if (DosSetFHState (fd, ulMode))
+            break;
+
+          result = 0;
+          break;
+
+        case F_GETFL:
+          result = 0;
+          break;
+
+        case F_SETFL:
+          if (arg != 0)
+            break;
+
+          result = 0;
+          break;
+
+        default:
+          errno = EINVAL;
+          break;
+        }
+    }
+
+  va_end (arg_ptr);
+
+  return result;
+}
+
+#endif
diff -Naur Retro68.old/libelf/src/fcntl.h Retro68/libelf/src/fcntl.h
--- Retro68.old/libelf/src/fcntl.h	1969-12-31 16:00:00.000000000 -0800
+++ Retro68/libelf/src/fcntl.h	2020-05-01 21:40:18.665836129 -0700
@@ -0,0 +1,218 @@
+/* Like <fcntl.h>, but with non-working flags defined to 0.
+
+   Copyright (C) 2006-2018 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* written by Paul Eggert */
+
+#ifndef _FCNTL_H
+#define _FCNTL_H
+
+/* Needed before <sys/stat.h>.
+   May also define off_t to a 64-bit type on native Windows.  */
+#include <sys/types.h>
+/* On some systems other than glibc, <sys/stat.h> is a prerequisite of
+   <fcntl.h>.  On glibc systems, we would like to avoid namespace pollution.
+   But on glibc systems, <fcntl.h> includes <sys/stat.h> inside an
+   extern "C" { ... } block, which leads to errors in C++ mode with the
+   overridden <sys/stat.h> from gnulib.  These errors are known to be gone
+   with g++ version >= 4.3.  */
+#if !(defined __GLIBC__ || defined __UCLIBC__) || (defined __cplusplus && defined GNULIB_NAMESPACE && (defined __ICC || !(__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))))
+# include <sys/stat.h>
+#endif
+
+#ifndef __GLIBC__ /* Avoid namespace pollution on glibc systems.  */
+# include <unistd.h>
+#endif
+
+/* Native Windows platforms declare open(), creat() in <io.h>.  */
+#if (defined _WIN32 && ! defined __CYGWIN__)
+# include <io.h>
+#endif
+
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+
+int fcntl(int fd, int cmd, ... /* arg */ );
+
+/* Fix up the FD_* macros, only known to be missing on mingw.  */
+
+#ifndef FD_CLOEXEC
+# define FD_CLOEXEC 1
+#endif
+
+/* Fix up the supported F_* macros.  Intentionally leave other F_*
+   macros undefined.  Only known to be missing on mingw.  */
+
+#ifndef F_DUPFD_CLOEXEC
+# define F_DUPFD_CLOEXEC 0x40000000
+/* Witness variable: 1 if gnulib defined F_DUPFD_CLOEXEC, 0 otherwise.  */
+# define GNULIB_defined_F_DUPFD_CLOEXEC 1
+#else
+# define GNULIB_defined_F_DUPFD_CLOEXEC 0
+#endif
+
+#ifndef F_DUPFD
+# define F_DUPFD 1
+#endif
+
+#ifndef F_GETFD
+# define F_GETFD 2
+#endif
+
+#if !defined O_DIRECT && defined O_DIRECTIO
+/* Tru64 spells it 'O_DIRECTIO'.  */
+# define O_DIRECT O_DIRECTIO
+#endif
+
+#if !defined O_CLOEXEC && defined O_NOINHERIT
+/* Mingw spells it 'O_NOINHERIT'.  */
+# define O_CLOEXEC O_NOINHERIT
+#endif
+
+#ifndef O_CLOEXEC
+# define O_CLOEXEC 0x40000000 /* Try to not collide with system O_* flags.  */
+# define GNULIB_defined_O_CLOEXEC 1
+#else
+# define GNULIB_defined_O_CLOEXEC 0
+#endif
+
+#ifndef O_DIRECT
+# define O_DIRECT 0
+#endif
+
+#ifndef O_DIRECTORY
+# define O_DIRECTORY 0
+#endif
+
+#ifndef O_DSYNC
+# define O_DSYNC 0
+#endif
+
+#ifndef O_EXEC
+# define O_EXEC O_RDONLY /* This is often close enough in older systems.  */
+#endif
+
+#ifndef O_IGNORE_CTTY
+# define O_IGNORE_CTTY 0
+#endif
+
+#ifndef O_NDELAY
+# define O_NDELAY 0
+#endif
+
+#ifndef O_NOATIME
+# define O_NOATIME 0
+#endif
+
+#ifndef O_NONBLOCK
+# define O_NONBLOCK O_NDELAY
+#endif
+
+#ifndef O_NOCTTY
+# define O_NOCTTY 0
+#endif
+
+#ifndef O_NOFOLLOW
+# define O_NOFOLLOW 0
+#endif
+
+#ifndef O_NOLINK
+# define O_NOLINK 0
+#endif
+
+#ifndef O_NOLINKS
+# define O_NOLINKS 0
+#endif
+
+#ifndef O_NOTRANS
+# define O_NOTRANS 0
+#endif
+
+#ifndef O_RSYNC
+# define O_RSYNC 0
+#endif
+
+#ifndef O_SEARCH
+# define O_SEARCH O_RDONLY /* This is often close enough in older systems.  */
+#endif
+
+#ifndef O_SYNC
+# define O_SYNC 0
+#endif
+
+#ifndef O_TTY_INIT
+# define O_TTY_INIT 0
+#endif
+
+#if ~O_ACCMODE & (O_RDONLY | O_WRONLY | O_RDWR | O_EXEC | O_SEARCH)
+# undef O_ACCMODE
+# define O_ACCMODE (O_RDONLY | O_WRONLY | O_RDWR | O_EXEC | O_SEARCH)
+#endif
+
+/* For systems that distinguish between text and binary I/O.
+   O_BINARY is usually declared in fcntl.h  */
+#if !defined O_BINARY && defined _O_BINARY
+  /* For MSC-compatible compilers.  */
+# define O_BINARY _O_BINARY
+# define O_TEXT _O_TEXT
+#endif
+
+#ifndef O_BINARY
+# define O_BINARY 0
+# define O_TEXT 0
+#endif
+
+/* Fix up the AT_* macros.  */
+
+/* Work around a bug in Solaris 9 and 10: AT_FDCWD is positive.  Its
+   value exceeds INT_MAX, so its use as an int doesn't conform to the
+   C standard, and GCC and Sun C complain in some cases.  If the bug
+   is present, undef AT_FDCWD here, so it can be redefined below.  */
+#if 0 < AT_FDCWD && AT_FDCWD == 0xffd19553
+# undef AT_FDCWD
+#endif
+
+/* Use the same bit pattern as Solaris 9, but with the proper
+   signedness.  The bit pattern is important, in case this actually is
+   Solaris with the above workaround.  */
+#ifndef AT_FDCWD
+# define AT_FDCWD (-3041965)
+#endif
+
+/* Use the same values as Solaris 9.  This shouldn't matter, but
+   there's no real reason to differ.  */
+#ifndef AT_SYMLINK_NOFOLLOW
+# define AT_SYMLINK_NOFOLLOW 4096
+#endif
+
+#ifndef AT_REMOVEDIR
+# define AT_REMOVEDIR 1
+#endif
+
+/* Solaris 9 lacks these two, so just pick unique values.  */
+#ifndef AT_SYMLINK_FOLLOW
+# define AT_SYMLINK_FOLLOW 2
+#endif
+
+#ifndef AT_EACCESS
+# define AT_EACCESS 4
+#endif
+
+#endif
diff -Naur Retro68.old/libelf/src/libelfP.h Retro68/libelf/src/libelfP.h
--- Retro68.old/libelf/src/libelfP.h	2020-03-19 19:23:50.021534162 -0700
+++ Retro68/libelf/src/libelfP.h	2020-03-22 11:03:58.732710654 -0700
@@ -30,7 +30,30 @@
 #ifndef _LIBELFP_H
 #define _LIBELFP_H 1
 
-#include <ar.h>
+//#include <ar.h>
+
+#ifndef INCLUDED_AR_H
+#define INCLUDED_AR_H
+#define ARMAG  "!<arch>\n"
+#define SARMAG  8
+
+#define ARFMAG  "`\n"
+
+struct ar_hdr
+{
+    char ar_name[ 16 ];
+    char ar_date[ 12 ];
+    char ar_uid[ 6 ];
+    char ar_gid[ 6 ];
+    char ar_mode[ 8 ];
+    char ar_size[ 10 ];
+    char ar_fmag[ 2 ];
+};
+
+#define SARFMAG  2
+#define SARHDR  sizeof( struct ar_hdr )
+#endif
+
 #include <gelf.h>
 
 #include <errno.h>
diff -Naur Retro68.old/libelf/src/mman.c Retro68/libelf/src/mman.c
--- Retro68.old/libelf/src/mman.c	1969-12-31 16:00:00.000000000 -0800
+++ Retro68/libelf/src/mman.c	2020-03-22 12:37:12.305942209 -0700
@@ -0,0 +1,181 @@
+
+#include <windows.h>
+#include <errno.h>
+#include <io.h>
+
+//#include <sys/mman.h>
+#include "mman.h"
+
+#ifndef FILE_MAP_EXECUTE
+#define FILE_MAP_EXECUTE    0x0020
+#endif /* FILE_MAP_EXECUTE */
+
+static int __map_mman_error(const DWORD err, const int deferr)
+{
+    if (err == 0)
+        return 0;
+    //TODO: implement
+    return err;
+}
+
+static DWORD __map_mmap_prot_page(const int prot)
+{
+    DWORD protect = 0;
+    
+    if (prot == PROT_NONE)
+        return protect;
+        
+    if ((prot & PROT_EXEC) != 0)
+    {
+        protect = ((prot & PROT_WRITE) != 0) ? 
+                    PAGE_EXECUTE_READWRITE : PAGE_EXECUTE_READ;
+    }
+    else
+    {
+        protect = ((prot & PROT_WRITE) != 0) ?
+                    PAGE_READWRITE : PAGE_READONLY;
+    }
+    
+    return protect;
+}
+
+static DWORD __map_mmap_prot_file(const int prot)
+{
+    DWORD desiredAccess = 0;
+    
+    if (prot == PROT_NONE)
+        return desiredAccess;
+        
+    if ((prot & PROT_READ) != 0)
+        desiredAccess |= FILE_MAP_READ;
+    if ((prot & PROT_WRITE) != 0)
+        desiredAccess |= FILE_MAP_WRITE;
+    if ((prot & PROT_EXEC) != 0)
+        desiredAccess |= FILE_MAP_EXECUTE;
+    
+    return desiredAccess;
+}
+
+void* mmap(void *addr, size_t len, int prot, int flags, int fildes, off_t off)
+{
+    HANDLE fm, h;
+    
+    void * map = MAP_FAILED;
+    
+#ifdef _MSC_VER
+#pragma warning(push)
+#pragma warning(disable: 4293)
+#endif
+
+    const DWORD dwFileOffsetLow = (sizeof(off_t) <= sizeof(DWORD)) ? 
+                    (DWORD)off : (DWORD)(off & 0xFFFFFFFFL);
+    const DWORD dwFileOffsetHigh = (sizeof(off_t) <= sizeof(DWORD)) ?
+                    (DWORD)0 : (DWORD)((off >> 32) & 0xFFFFFFFFL);
+    const DWORD protect = __map_mmap_prot_page(prot);
+    const DWORD desiredAccess = __map_mmap_prot_file(prot);
+
+    const off_t maxSize = off + (off_t)len;
+
+    const DWORD dwMaxSizeLow = (sizeof(off_t) <= sizeof(DWORD)) ? 
+                    (DWORD)maxSize : (DWORD)(maxSize & 0xFFFFFFFFL);
+    const DWORD dwMaxSizeHigh = (sizeof(off_t) <= sizeof(DWORD)) ?
+                    (DWORD)0 : (DWORD)((maxSize >> 32) & 0xFFFFFFFFL);
+
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif
+
+    errno = 0;
+    
+    if (len == 0 
+        /* Unsupported flag combinations */
+        || (flags & MAP_FIXED) != 0
+        /* Usupported protection combinations */
+        || prot == PROT_EXEC)
+    {
+        errno = EINVAL;
+        return MAP_FAILED;
+    }
+    
+    h = ((flags & MAP_ANONYMOUS) == 0) ? 
+                    (HANDLE)_get_osfhandle(fildes) : INVALID_HANDLE_VALUE;
+
+    if ((flags & MAP_ANONYMOUS) == 0 && h == INVALID_HANDLE_VALUE)
+    {
+        errno = EBADF;
+        return MAP_FAILED;
+    }
+
+    fm = CreateFileMapping(h, NULL, protect, dwMaxSizeHigh, dwMaxSizeLow, NULL);
+
+    if (fm == NULL)
+    {
+        errno = __map_mman_error(GetLastError(), EPERM);
+        return MAP_FAILED;
+    }
+  
+    map = MapViewOfFile(fm, desiredAccess, dwFileOffsetHigh, dwFileOffsetLow, len);
+
+    CloseHandle(fm);
+  
+    if (map == NULL)
+    {
+        errno = __map_mman_error(GetLastError(), EPERM);
+        return MAP_FAILED;
+    }
+
+    return map;
+}
+
+int munmap(void *addr, size_t len)
+{
+    if (UnmapViewOfFile(addr))
+        return 0;
+        
+    errno =  __map_mman_error(GetLastError(), EPERM);
+    
+    return -1;
+}
+
+int mprotect(void *addr, size_t len, int prot)
+{
+    DWORD newProtect = __map_mmap_prot_page(prot);
+    DWORD oldProtect = 0;
+    
+    if (VirtualProtect(addr, len, newProtect, &oldProtect))
+        return 0;
+    
+    errno =  __map_mman_error(GetLastError(), EPERM);
+    
+    return -1;
+}
+
+int msync(void *addr, size_t len, int flags)
+{
+    if (FlushViewOfFile(addr, len))
+        return 0;
+    
+    errno =  __map_mman_error(GetLastError(), EPERM);
+    
+    return -1;
+}
+
+int mlock(const void *addr, size_t len)
+{
+    if (VirtualLock((LPVOID)addr, len))
+        return 0;
+        
+    errno =  __map_mman_error(GetLastError(), EPERM);
+    
+    return -1;
+}
+
+int munlock(const void *addr, size_t len)
+{
+    if (VirtualUnlock((LPVOID)addr, len))
+        return 0;
+        
+    errno =  __map_mman_error(GetLastError(), EPERM);
+    
+    return -1;
+}
diff -Naur Retro68.old/libelf/src/mman.h Retro68/libelf/src/mman.h
--- Retro68.old/libelf/src/mman.h	1969-12-31 16:00:00.000000000 -0800
+++ Retro68/libelf/src/mman.h	2020-03-22 12:36:35.449958499 -0700
@@ -0,0 +1,55 @@
+/*
+ * sys/mman.h
+ * mman-win32
+ */
+
+#ifndef _SYS_MMAN_H_
+#define _SYS_MMAN_H_
+
+#ifndef _WIN32_WINNT		// Allow use of features specific to Windows XP or later.                   
+#define _WIN32_WINNT 0x0501	// Change this to the appropriate value to target other versions of Windows.
+#endif						
+
+/* All the headers include this file. */
+#ifndef _MSC_VER
+#include <_mingw.h>
+#endif
+
+#include <sys/types.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define PROT_NONE       0
+#define PROT_READ       1
+#define PROT_WRITE      2
+#define PROT_EXEC       4
+
+#define MAP_FILE        0
+#define MAP_SHARED      1
+#define MAP_PRIVATE     2
+#define MAP_TYPE        0xf
+#define MAP_FIXED       0x10
+#define MAP_ANONYMOUS   0x20
+#define MAP_ANON        MAP_ANONYMOUS
+
+#define MAP_FAILED      ((void *)-1)
+
+/* Flags for msync. */
+#define MS_ASYNC        1
+#define MS_SYNC         2
+#define MS_INVALIDATE   4
+
+void*   mmap(void *addr, size_t len, int prot, int flags, int fildes, off_t off);
+int     munmap(void *addr, size_t len);
+int     mprotect(void *addr, size_t len, int prot);
+int     msync(void *addr, size_t len, int flags);
+int     mlock(const void *addr, size_t len);
+int     munlock(const void *addr, size_t len);
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif /*  _SYS_MMAN_H_ */
diff -Naur Retro68.old/libelf/src/nlist.c Retro68/libelf/src/nlist.c
--- Retro68.old/libelf/src/nlist.c	2020-03-19 19:23:50.025534162 -0700
+++ Retro68/libelf/src/nlist.c	2020-05-09 20:38:06.247153527 -0700
@@ -37,8 +37,17 @@
 #include <nlist.h>
 #include <unistd.h>
 
+#include <sys/stat.h>
+
 #include "libelfP.h"
 
+#define _O_RDONLY      0
+#define _O_WRONLY      1
+#define _O_RDWR        2
+
+#define O_RDONLY _O_RDONLY
+#define O_WRONLY _O_WRONLY
+#define O_RDWR _O_RDWR
 
 struct hashentry
 {
@@ -71,7 +80,7 @@
   size_t cnt;
 
   /* Open the file.  */
-  fd = open (filename, O_RDONLY);
+  fd = open (filename, _O_RDONLY);
   if (fd == -1)
     {
       __libelf_seterrno (ELF_E_NOFILE);
diff -Naur Retro68.old/libelf/src/portable_endian.h Retro68/libelf/src/portable_endian.h
--- Retro68.old/libelf/src/portable_endian.h	2020-03-19 19:23:50.025534162 -0700
+++ Retro68/libelf/src/portable_endian.h	2020-05-02 11:57:17.935395653 -0700
@@ -63,6 +63,33 @@
 #	include <winsock2.h>
 #	include <sys/param.h>
 
+static long long ntohll(long long x)
+{
+	return ((unsigned long long)(((unsigned char *)(&x))[7]) << 0LL)
+	     | ((unsigned long long)(((unsigned char *)(&x))[6]) << 8LL)
+	     | ((unsigned long long)(((unsigned char *)(&x))[5]) << 16LL)
+	     | ((unsigned long long)(((unsigned char *)(&x))[4]) << 24LL)
+	     | ((unsigned long long)(((unsigned char *)(&x))[3]) << 32LL)
+	     | ((unsigned long long)(((unsigned char *)(&x))[2]) << 40LL)
+	     | ((unsigned long long)(((unsigned char *)(&x))[1]) << 48LL)
+	     | ((unsigned long long)(((unsigned char *)(&x))[0]) << 56LL);
+}
+
+static long long htonll(long long x)
+{
+	unsigned char data[8] = {};
+	data[0] = (x & 0xFF00000000000000LL) >> 56LL;
+	data[1] = (x & 0x00FF000000000000LL) >> 48LL;
+	data[2] = (x & 0x0000FF0000000000LL) >> 40LL;
+	data[3] = (x & 0x000000FF00000000LL) >> 32LL;
+	data[4] = (x & 0x00000000FF000000LL) >> 24LL;
+	data[5] = (x & 0x0000000000FF0000LL) >> 16LL;
+	data[6] = (x & 0x000000000000FF00LL) >> 8LL;
+	data[7] = (x & 0x00000000000000FFLL) >> 0LL;
+
+	return *(long long *)(data);
+}
+
 #	if BYTE_ORDER == LITTLE_ENDIAN
 
 #		define htobe16(x) htons(x)
diff -Naur Retro68.old/libelf/src/sysconf.cpp Retro68/libelf/src/sysconf.cpp
--- Retro68.old/libelf/src/sysconf.cpp	1969-12-31 16:00:00.000000000 -0800
+++ Retro68/libelf/src/sysconf.cpp	2020-05-01 20:18:50.387936276 -0700
@@ -0,0 +1,1976 @@
+#include <windows.h>
+#include <lmcons.h>
+#include <time.h>
+#include <errno.h>
+#include <limits.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <winreg.h>
+
+// Check windows
+#if !defined(_WIN32) && !defined(_WIN16) && !defined(_WIN64)
+#if WIN16 || _WIN16_ || ___WIN16 || ___WIN16__ || WIN32 || _WIN32_ || ___WIN32 || ___WIN32__ || WIN64 || _WIN64_ || ___WIN64 || ___WIN64__
+#if WIN64 || _WIN64_ || ___WIN64 || ___WIN64__
+#define _WIN64
+#elif WIN16 || _WIN16_ || ___WIN16 || ___WIN16__
+#define _WIN16
+#else
+#define _WIN32
+#endif
+#endif
+#endif
+
+// Check GCC
+#if !defined(_WIN32) && !defined(_WIN16) && !defined(_WIN64)
+#if __GNUC__
+#if __x86_64__ || __ppc64__
+#define _WIN64
+#else
+#define _WIN32
+#endif
+#endif
+#endif
+
+#ifdef _WIN64
+#include <mfobjects.h>
+#endif
+
+//using namespace std;
+
+#ifndef MAX
+#define MAX(A, B) (((A) > (B)) ? (A) : (B))
+#endif
+
+#ifndef TEXT
+	#ifndef __TEXT
+		#ifdef  UNICODE                     // r_winnt
+			#define __TEXT(quote) L##quote      // r_winnt
+		#else   /* UNICODE */               // r_winnt
+			#define __TEXT(quote) quote         // r_winnt
+		#endif /* UNICODE */                // r_winnt
+	#endif
+	#define TEXT(quote) __TEXT(quote)   // r_winnt
+#endif
+
+#ifndef RE_DUP_MAX
+#define RE_DUP_MAX 255
+#endif
+
+/* TODO: found this through ReactOS limits.h, couldn't find through any official windows sources and no idea what the equivelent function
+   would be*/
+#ifndef COLL_WEIGHTS_MAX
+#define COLL_WEIGHTS_MAX 2
+#endif
+
+#ifndef SYMLOOP_MAX // shamelessly stolen from Linux as Windows doesn't have symlinks separate from cygwin
+	#ifdef MAXSYMLINKS
+		#define SYMLOOP_MAX MAXSYMLINKS
+	#else
+		#define SYMLOOP_MAX 8
+	#endif
+#endif
+
+typedef struct _LMEMORYSTATUSEX {
+	DWORD dwLength;
+	DWORD dwMemoryLoad;
+	DWORDLONG ullTotalPhys;
+	DWORDLONG ullAvailPhys;
+	DWORDLONG ullTotalPageFile;
+	DWORDLONG ullAvailPageFile;
+	DWORDLONG ullTotalVirtual;
+	DWORDLONG ullAvailVirtual;
+	DWORDLONG ullAvailExtendedVirtual;
+} LMEMORYSTATUSEX;
+
+typedef LMEMORYSTATUSEX * PLMEMORYSTATUSEX;
+typedef LMEMORYSTATUSEX FAR * LPLMEMORYSTATUSEX;
+
+typedef struct _LOSVERSIONINFOEXW {
+  DWORD dwOSVersionInfoSize;
+  DWORD dwMajorVersion;
+  DWORD dwMinorVersion;
+  DWORD dwBuildNumber;
+  DWORD dwPlatformId;
+  WCHAR szCSDVersion[128];
+  WORD  wServicePackMajor;
+  WORD  wServicePackMinor;
+  WORD  wSuiteMask;
+  BYTE  wProductType;
+  BYTE  wReserved;
+} LOSVERSIONINFOEXW;
+
+typedef struct _LOSVERSIONINFOEXA {
+  DWORD dwOSVersionInfoSize;
+  DWORD dwMajorVersion;
+  DWORD dwMinorVersion;
+  DWORD dwBuildNumber;
+  DWORD dwPlatformId;
+  CHAR  szCSDVersion[128];
+  WORD  wServicePackMajor;
+  WORD  wServicePackMinor;
+  WORD  wSuiteMask;
+  BYTE  wProductType;
+  BYTE  wReserved;
+} LOSVERSIONINFOEXA;
+
+typedef struct _LOSVERSIONINFOA {
+  DWORD dwOSVersionInfoSize;
+  DWORD dwMajorVersion;
+  DWORD dwMinorVersion;
+  DWORD dwBuildNumber;
+  DWORD dwPlatformId;
+  CHAR  szCSDVersion[128];
+} LOSVERSIONINFOA;
+
+typedef struct _LOSVERSIONINFOW {
+  DWORD dwOSVersionInfoSize;
+  DWORD dwMajorVersion;
+  DWORD dwMinorVersion;
+  DWORD dwBuildNumber;
+  DWORD dwPlatformId;
+  WCHAR szCSDVersion[128];
+} LOSVERSIONINFOW;
+
+// workarround for NT 3.X compilers not defining correctly...
+typedef struct _LSYSTEM_INFO {
+    union {
+        DWORD dwOemId;          // Obsolete field...do not use
+        struct {
+            WORD wProcessorArchitecture;
+            WORD wReserved;
+        } DUMMYSTRUCT;
+    } DUMMYUNION;
+    DWORD dwPageSize;
+    LPVOID lpMinimumApplicationAddress;
+    LPVOID lpMaximumApplicationAddress;
+    DWORD dwActiveProcessorMask;
+    DWORD dwNumberOfProcessors;
+    DWORD dwProcessorType;
+    DWORD dwAllocationGranularity;
+    WORD wProcessorLevel;
+    WORD wProcessorRevision;
+} LSYSTEM_INFO;
+
+typedef LSYSTEM_INFO * PLSYSTEM_INFO;
+typedef LSYSTEM_INFO FAR * LPLSYSTEM_INFO;
+
+typedef LONG NTSTATUS;
+typedef LONG LSTATUS;
+#define STATUS_SUCCESS 0x00000000L
+
+typedef LOSVERSIONINFOEXA *PLOSVERSIONINFOEXA;
+typedef LOSVERSIONINFOEXA FAR * LPLOSVERSIONINFOEXA;
+
+typedef LOSVERSIONINFOEXW LRTL_OSVERSIONINFOEXW;
+typedef LOSVERSIONINFOEXW *PLOSVERSIONINFOEXW;
+typedef LOSVERSIONINFOEXW *PLRTL_OSVERSIONINFOEXW;
+
+typedef LOSVERSIONINFOEXW FAR * LPLOSVERSIONINFOEXW;
+typedef LOSVERSIONINFOEXW FAR * LPLRTL_OSVERSIONINFOEXW;
+
+typedef LOSVERSIONINFOA * PLOSVERSIONINFOA;
+typedef LOSVERSIONINFOA FAR * LPLOSVERSIONINFOA;
+
+typedef LOSVERSIONINFOW LRTL_OSVERSIONINFOW;
+typedef LOSVERSIONINFOW * PLOSVERSIONINFOW;
+typedef LOSVERSIONINFOW *PLRTL_OSVERSIONINFOW;
+
+typedef LOSVERSIONINFOW FAR * LPLOSVERSIONINFOW;
+typedef LOSVERSIONINFOW FAR * LPLRTL_OSVERSIONINFOW;
+
+typedef NTSTATUS (WINAPI *PRtlGetVersion)(PLRTL_OSVERSIONINFOW lpVersionInfo);
+typedef NTSTATUS (WINAPI FAR *LPRtlGetVersion)(PLRTL_OSVERSIONINFOW lpVersionInfo);
+
+typedef NTSTATUS (WINAPI *PRtlGetVersionEX)(PLRTL_OSVERSIONINFOEXW lpVersionInfo);
+typedef NTSTATUS (WINAPI FAR *LPRtlGetVersionEX)(PLRTL_OSVERSIONINFOEXW lpVersionInfo);
+
+typedef BOOL (WINAPI *PGetVersionEXA)(LPLOSVERSIONINFOA lpVersionInformation);
+typedef BOOL (WINAPI FAR *LPGetVersionEXA)(LPLOSVERSIONINFOA lpVersionInformation);
+
+typedef BOOL (WINAPI *PGetVersionEXEXA)(LPLOSVERSIONINFOEXA lpVersionInformation);
+typedef BOOL (WINAPI FAR *LPGetVersionEXEXA)(LPLOSVERSIONINFOEXA lpVersionInformation);
+
+typedef BOOL (WINAPI *PGlobalMemoryStatusEX)(LPLMEMORYSTATUSEX lpBuffer);
+typedef BOOL (WINAPI FAR *LPGlobalMemoryStatusEX)(LPLMEMORYSTATUSEX lpBuffer);
+
+typedef BOOL (WINAPI *PGlobalMemoryStatus)(LPMEMORYSTATUS lpBuffer);
+typedef BOOL (WINAPI FAR *LPGlobalMemoryStatus)(LPMEMORYSTATUS lpBuffer);
+
+typedef LSTATUS (WINAPI *PRegOpenKeyExA)(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
+typedef LSTATUS (WINAPI FAR *LPRegOpenKeyExA)(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
+
+typedef LSTATUS (WINAPI *PRegQueryValueExA)(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
+typedef LSTATUS (WINAPI FAR *LPRegQueryValueExA)(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
+
+#ifndef REG_OPTION_OPEN_LINK
+#define REG_OPTION_OPEN_LINK        (0x00000008L)   // Open symbolic link
+#endif
+
+#ifndef READ_CONTROL
+#define READ_CONTROL                     (0x00020000L)
+#endif
+
+#ifndef STANDARD_RIGHTS_READ
+#define STANDARD_RIGHTS_READ             (READ_CONTROL)
+#endif
+
+#ifndef KEY_QUERY_VALUE
+#define KEY_QUERY_VALUE         (0x0001)
+#endif
+
+#ifndef KEY_ENUMERATE_SUB_KEYS
+#define KEY_ENUMERATE_SUB_KEYS  (0x0008)
+#endif
+
+#ifndef KEY_NOTIFY
+#define KEY_NOTIFY              (0x0010)
+#endif
+
+#ifndef SYNCHRONIZE
+#define SYNCHRONIZE                      (0x00100000L)
+#endif
+
+#ifndef KEY_READ
+#define KEY_READ                ((STANDARD_RIGHTS_READ       |\
+                                  KEY_QUERY_VALUE            |\
+                                  KEY_ENUMERATE_SUB_KEYS     |\
+                                  KEY_NOTIFY)                 \
+                                  &                           \
+                                 (~SYNCHRONIZE))
+#endif
+
+class GetWindowsInfo
+{
+	private:
+		static SYSTEM_INFO systemInfo;
+		static BOOL zSetSystemInfo;
+		static HMODULE hKernel32;
+		static HMODULE hAdvapi32;
+		static HMODULE hNtDll;
+		static FARPROC fpGetVersionEx;
+		static FARPROC fpRtlGetVersion;
+		static FARPROC fpGlobalMemoryStatusEx;
+		static FARPROC fpGlobalMemoryStatus;
+		static FARPROC fpRegOpenKeyExA;
+		static FARPROC fpRegQueryValueExA;
+		static int numInstances;
+		static size_t zStackUsage;
+		static BOOL zStackUsageSet;
+		static BOOL zVersionInfoSet;
+		static BOOL zIsNt;
+		static BOOL zIsWin32s;
+		static DWORD dwMajorVersion;
+		static DWORD dwMinorVersion;
+		static DWORD dwBuild;
+		static DWORD dwPlatformId;
+		static BYTE wProductType;
+
+		static unsigned long mytol(LPCSTR str)
+		{
+			unsigned long t = 0;
+			sscanf(str, "%lu", &t);
+
+			return t;
+		}
+
+		static unsigned int mytoi(LPCSTR str)
+		{
+			unsigned long t = 0;
+			sscanf(str, "%lu", &t);
+
+			if(t >= UINT_MAX)
+			{
+				t = UINT_MAX;
+			}
+
+			return (unsigned int)t;
+		}
+
+		static unsigned short mytos(LPCSTR str)
+		{
+			unsigned long t = 0;
+			sscanf(str, "%lu", &t);
+
+			if(t >= USHRT_MAX)
+			{
+				t = USHRT_MAX;
+			}
+
+			return (unsigned short)t;
+		}
+
+		static unsigned char mytob(LPCSTR str)
+		{
+			unsigned long t = 0;
+			sscanf(str, "%lu", &t);
+
+			if(t >= UCHAR_MAX)
+			{
+				t = UCHAR_MAX;
+			}
+
+			return (unsigned char)t;
+		}
+
+		static int my_scprintf(const char * format, ...)
+		{
+			char *strBuf = NULL;
+			int curSize = 0;
+			int size = 0;
+			va_list ap;
+
+			va_start(ap, format);
+
+			do
+			{
+				if(curSize == 0)
+				{
+					curSize = 1;
+					strBuf = (char *)malloc(sizeof (char) * curSize);
+				}
+				else
+				{
+					curSize += 12;
+					strBuf = (char *)realloc(strBuf, sizeof (char) * curSize);
+				}
+
+				if(strBuf == NULL)
+				{
+					size = 1;
+				}
+				else
+				{
+					size = _vsnprintf(strBuf, curSize - 1, format, ap);
+				}
+			} while(strBuf != NULL && size < 0);
+
+			if(strBuf != NULL)
+			{
+				free(strBuf);
+			}
+
+			va_end(ap);
+
+			return size - 1;
+		}
+
+	public:
+		GetWindowsInfo()
+		{
+			if(numInstances == 0)
+			{
+				if(!zSetSystemInfo)
+				{
+					GetSystemInfo(&systemInfo);
+					zSetSystemInfo = TRUE;
+				}
+				hNtDll = LoadLibrary(TEXT("NTDLL"));
+				hKernel32 = LoadLibrary(TEXT("KERNEL32"));
+				hAdvapi32 = LoadLibrary(TEXT("ADVAPI32"));
+
+				if(hNtDll != 0)
+				{
+					fpRtlGetVersion = GetProcAddress(hNtDll, TEXT("RtlGetVersion"));
+					if(fpRtlGetVersion != NULL)
+					{
+						zIsNt = TRUE;
+						zIsWin32s = FALSE;
+					}
+				}
+
+				if(hKernel32 != 0)
+				{
+					fpGetVersionEx = GetProcAddress(hKernel32, TEXT("GetVersionExA"));
+
+					if(fpGetVersionEx == NULL)
+					{
+						fpGetVersionEx = GetProcAddress(hKernel32, TEXT("GetVersionEx"));
+					}
+
+					fpGlobalMemoryStatusEx = GetProcAddress(hKernel32, TEXT("GlobalMemoryStatusEx"));
+					fpGlobalMemoryStatus = GetProcAddress(hKernel32, TEXT("GlobalMemoryStatus"));
+				}
+
+				if(hAdvapi32 != 0)
+				{
+					fpRegOpenKeyExA = GetProcAddress(hAdvapi32, TEXT("RegOpenKeyExA"));
+					if(fpRegOpenKeyExA == NULL)
+					{
+						fpRegOpenKeyExA = GetProcAddress(hAdvapi32, TEXT("RegOpenKeyEx"));
+					}
+
+					fpRegQueryValueExA = GetProcAddress(hAdvapi32, TEXT("RegQueryValueExA"));
+					if(fpRegQueryValueExA == NULL)
+					{
+						fpRegQueryValueExA = GetProcAddress(hAdvapi32, TEXT("RegQueryValueEx"));
+					}
+				}
+
+				if(!zIsNt)
+				{
+					DWORD v = GetVersion();
+					zIsNt = !(v & 0x80000000);
+					zIsWin32s = ((!zIsNt) && (DWORD)(LOBYTE(LOWORD(v))) <= 3);
+				}
+
+				GetStackUsage();
+			}
+			numInstances++;
+		}
+
+		static BOOL GetWindowsRegistryKey(PHKEY phKeyCurrentVersion, PHKEY phKeyProductOptions)
+		{
+			BOOL success = FALSE;
+			*phKeyCurrentVersion = 0;
+			*phKeyProductOptions = 0;
+
+			if(fpRegOpenKeyExA)
+			{
+				LSTATUS regOpenStatus = 0;
+				HKEY hKeyOut = 0;
+
+				regOpenStatus = ((LPRegOpenKeyExA)fpRegOpenKeyExA)(HKEY_LOCAL_MACHINE,
+											TEXT("Software\\Microsoft\\Windows\\CurrentVersion"),
+											REG_OPTION_OPEN_LINK,
+											KEY_READ,
+											&hKeyOut);
+
+				if(regOpenStatus == 0)
+				{
+					*phKeyCurrentVersion = hKeyOut;
+					success = TRUE;
+				}
+
+				regOpenStatus = ((LPRegOpenKeyExA)fpRegOpenKeyExA)(HKEY_LOCAL_MACHINE,
+											TEXT("SYSTEM\\CurrentControlSet\\Control\\ProductOptions"),
+											REG_OPTION_OPEN_LINK,
+											KEY_READ,
+											&hKeyOut);
+
+				if(regOpenStatus == 0)
+				{
+					*phKeyProductOptions = hKeyOut;
+					success = TRUE;
+				}
+			}
+
+			return success;
+		}
+
+		static BOOL ReadWindowsRegistryValue(PHKEY parent, LPCSTR value, HLOCAL *pdataHandle, LPBYTE *pdata)
+		{
+			BOOL result = FALSE;
+			HLOCAL dataHandle = 0;
+			LPBYTE data = NULL;
+			DWORD dataSize = 256;
+
+			*pdataHandle = 0;
+			*pdata = NULL;
+
+			if(fpRegQueryValueExA != NULL)
+			{
+				DWORD dwType;
+				dataHandle = LocalAlloc(LMEM_FIXED, dataSize);
+
+				if(dataHandle != 0)
+				{
+					LSTATUS status = 0;
+					data = (LPBYTE)LocalLock(dataHandle);
+
+					if(data != 0)
+					{
+						status = ((LPRegQueryValueExA)fpRegQueryValueExA)(*parent, value, NULL, &dwType, data, &dataSize);
+
+						while(status == ERROR_MORE_DATA)
+						{
+							LocalUnlock(data);
+							data = NULL;
+							dataSize += 256;
+
+							dataHandle = LocalReAlloc(dataHandle, dataSize, LMEM_ZEROINIT);
+
+							if(dataHandle != 0)
+							{
+								data = (LPBYTE)LocalLock(dataHandle);
+
+								if(data != 0)
+								{
+									status = ((LPRegQueryValueExA)fpRegQueryValueExA)(*parent, value, NULL, &dwType, data, &dataSize);
+								}
+							}
+						}
+					}
+
+					if(data != NULL && status == 0)
+					{
+						HLOCAL envStrHandle = 0;
+						LPSTR envStr = NULL;
+						DWORD nSize = 0;
+						DWORD tmp1;
+						//QWORD tmp2;
+						char t;
+
+						if(dwType == REG_BINARY)
+						{
+							result = TRUE;
+							*pdata = data;
+							*pdataHandle = dataHandle;
+						}
+						else if(dwType == REG_DWORD)
+						{
+							tmp1 = *((DWORD*)data);
+							nSize = my_scprintf("%lu", (unsigned long)tmp1);
+
+							if(nSize > 0)
+							{
+								envStrHandle = LocalAlloc(LMEM_FIXED, (nSize + 1) * sizeof (char));
+
+								if(envStrHandle != 0)
+								{
+									envStr = (LPSTR)LocalLock(envStrHandle);
+
+									if(envStr != NULL)
+									{
+										result = TRUE;
+										wsprintfA(envStr, "%lu", (unsigned long)tmp1);
+										*pdata = (LPBYTE)envStr;
+										*pdataHandle = envStrHandle;
+									}
+									else
+									{
+										LocalFree(envStrHandle);
+										envStrHandle = NULL;
+									}
+								}
+
+								LocalUnlock(data);
+								data = NULL;
+								LocalFree(dataHandle);
+								dataHandle = 0;
+							}
+						}
+						else if(dwType == REG_DWORD_LITTLE_ENDIAN)
+						{
+							tmp1 = ((DWORD)(((BYTE *)data)[3]) << 24) |
+									((DWORD)(((BYTE *)data)[2]) << 16) |
+									((DWORD)(((BYTE *)data)[1]) << 8) |
+									((DWORD)(((BYTE *)data)[0]));
+							nSize = my_scprintf("%lu", (unsigned long)tmp1);
+
+							if(nSize > 0)
+							{
+								envStrHandle = LocalAlloc(LMEM_FIXED, (nSize + 1) * sizeof (char));
+
+								if(envStrHandle != 0)
+								{
+									envStr = (LPSTR)LocalLock(envStrHandle);
+
+									if(envStr != NULL)
+									{
+										result = TRUE;
+										wsprintfA(envStr, "%lu", (unsigned long)tmp1);
+										*pdata = (LPBYTE)envStr;
+										*pdataHandle = envStrHandle;
+									}
+									else
+									{
+										LocalFree(envStrHandle);
+										envStrHandle = NULL;
+									}
+								}
+
+								LocalUnlock(data);
+								data = NULL;
+								LocalFree(dataHandle);
+								dataHandle = 0;
+							}
+						}
+						else if(dwType == REG_DWORD_BIG_ENDIAN)
+						{
+							tmp1 = ((DWORD)(((BYTE *)data)[0]) << 24) |
+									((DWORD)(((BYTE *)data)[1]) << 16) |
+									((DWORD)(((BYTE *)data)[2]) << 8) |
+									((DWORD)(((BYTE *)data)[3]));
+							nSize = my_scprintf("%lu", (unsigned long)tmp1);
+
+							if(nSize > 0)
+							{
+								envStrHandle = LocalAlloc(LMEM_FIXED, (nSize + 1) * sizeof (char));
+
+								if(envStrHandle != 0)
+								{
+									envStr = (LPSTR)LocalLock(envStrHandle);
+
+									if(envStr != NULL)
+									{
+										result = TRUE;
+										wsprintfA(envStr, "%lu", (unsigned long)tmp1);
+										*pdata = (LPBYTE)envStr;
+										*pdataHandle = envStrHandle;
+									}
+									else
+									{
+										LocalFree(envStrHandle);
+										envStrHandle = NULL;
+									}
+								}
+
+								LocalUnlock(data);
+								data = NULL;
+								LocalFree(dataHandle);
+								dataHandle = 0;
+							}
+						}
+						else if(dwType == REG_EXPAND_SZ)
+						{
+							nSize = ExpandEnvironmentStringsA((LPCSTR)data, &t, nSize);
+
+							envStrHandle = LocalAlloc(LMEM_FIXED, nSize);
+
+							if(envStrHandle != 0)
+							{
+								envStr = (LPSTR)LocalLock(envStrHandle);
+
+								if(envStr != NULL)
+								{
+									ExpandEnvironmentStringsA((LPCSTR)data, envStr, nSize);
+
+									result = TRUE;
+									*pdata = (LPBYTE)envStr;
+									*pdataHandle = envStrHandle;
+								}
+							}
+
+							LocalUnlock(data);
+							data = NULL;
+							LocalFree(dataHandle);
+							dataHandle = 0;
+						}
+						else if(dwType == REG_LINK)
+						{
+							result = TRUE;
+							*pdata = data;
+							*pdataHandle = dataHandle;
+						}
+						else if(dwType == REG_MULTI_SZ)
+						{
+							result = TRUE;
+							*pdata = data;
+							*pdataHandle = dataHandle;
+						}
+						else if(dwType == REG_NONE)
+						{
+							result = TRUE;
+							*pdata = NULL;
+							*pdataHandle = 0;
+
+							LocalUnlock(data);
+							data = NULL;
+							LocalFree(dataHandle);
+							dataHandle = 0;
+						}
+						#ifdef REG_QWORD
+						else if(dwType == REG_QWORD)
+						{
+						}
+						#endif
+						#ifdef REG_QWORD_LITTLE_ENDIAN
+						else if(dwType == REG_QWORD_LITTLE_ENDIAN)
+						{
+						}
+						#endif
+						else if(dwType == REG_SZ)
+						{
+							result = TRUE;
+							*pdata = data;
+							*pdataHandle = dataHandle;
+						}
+					}
+				}
+			}
+
+			return result;
+		}
+
+		static void GetWindowsVersion(DWORD &minorVersion, DWORD &majorVersion, DWORD &build, DWORD &platformId, BYTE &productType, BOOL &isNT, BOOL &isWin32s, WORD &processorArchitecture)
+		{
+			if(!zVersionInfoSet)
+			{
+				BOOL success = FALSE;
+
+				majorVersion = 0;
+				minorVersion = 0;
+				build = 0;
+				dwBuild = 0;
+				dwPlatformId = 0;
+				dwMajorVersion = 0;
+				dwMinorVersion = 0;
+				wProductType = 0;
+
+				if(!success && fpRtlGetVersion != NULL)
+				{
+					LRTL_OSVERSIONINFOEXW osversioninfo;
+					memset(&osversioninfo, '\0', sizeof (LRTL_OSVERSIONINFOEXW));
+					osversioninfo.dwOSVersionInfoSize = sizeof (LRTL_OSVERSIONINFOEXW);
+					NTSTATUS status = ((LPRtlGetVersionEX)fpRtlGetVersion)(&osversioninfo);
+					if(status == STATUS_SUCCESS)
+					{
+						success = TRUE;
+						majorVersion = osversioninfo.dwMajorVersion;
+						minorVersion = osversioninfo.dwMinorVersion;
+						build = osversioninfo.dwBuildNumber;
+						platformId = osversioninfo.dwPlatformId;
+						productType = osversioninfo.wProductType;
+
+						dwMajorVersion = majorVersion;
+						dwMinorVersion = minorVersion;
+						dwBuild = build;
+						dwPlatformId = platformId;
+						wProductType = productType;
+
+						zVersionInfoSet = TRUE;
+					}
+				}
+
+				if(!success && fpGetVersionEx != NULL)
+				{
+					LOSVERSIONINFOEXA versionInformation;
+					memset(&versionInformation, '\0', sizeof (LOSVERSIONINFOEXA));
+					versionInformation.dwOSVersionInfoSize = sizeof (LOSVERSIONINFOEXA);
+					success = ((LPGetVersionEXEXA)fpGetVersionEx)(&versionInformation);
+					if(success)
+					{
+						majorVersion = versionInformation.dwMajorVersion;
+						minorVersion = versionInformation.dwMinorVersion;
+						build = versionInformation.dwBuildNumber;
+						platformId = versionInformation.dwPlatformId;
+						productType = versionInformation.wProductType;
+
+						dwMajorVersion = majorVersion;
+						dwMinorVersion = minorVersion;
+						dwBuild = build;
+						dwPlatformId = platformId;
+						wProductType = productType;
+
+						zVersionInfoSet = TRUE;
+					}
+				}
+
+				if(!success && fpRtlGetVersion != NULL)
+				{
+					LRTL_OSVERSIONINFOW osversioninfo;
+					memset(&osversioninfo, '\0', sizeof (LRTL_OSVERSIONINFOW));
+					osversioninfo.dwOSVersionInfoSize = sizeof (LRTL_OSVERSIONINFOW);
+					NTSTATUS status = ((LPRtlGetVersion)fpRtlGetVersion)(&osversioninfo);
+					if(status == STATUS_SUCCESS)
+					{
+						HKEY hKeyCurrentVersion = 0;
+						HKEY hKeyProductOptions = 0;
+
+						success = TRUE;
+						majorVersion = osversioninfo.dwMajorVersion;
+						minorVersion = osversioninfo.dwMinorVersion;
+						build = osversioninfo.dwBuildNumber;
+						platformId = osversioninfo.dwPlatformId;
+
+						dwMajorVersion = majorVersion;
+						dwMinorVersion = minorVersion;
+						dwBuild = build;
+						dwPlatformId = platformId;
+						productType = 0;
+
+						GetWindowsRegistryKey(&hKeyCurrentVersion, &hKeyProductOptions);
+
+						if(productType == 0 && hKeyCurrentVersion != 0)
+						{
+							HLOCAL dataHandle = NULL;
+							LPBYTE data;
+
+							if(ReadWindowsRegistryValue(&hKeyCurrentVersion, "ProductType", &dataHandle, &data))
+							{
+								productType = mytob((LPSTR)data);
+
+								LocalUnlock(data);
+								data = NULL;
+								LocalFree(dataHandle);
+								dataHandle = 0;
+							}
+						}
+						if(productType == 0 && hKeyProductOptions != 0)
+						{
+							HLOCAL dataHandle = NULL;
+							LPBYTE data;
+
+							if(ReadWindowsRegistryValue(&hKeyProductOptions, "ProductType", &dataHandle, &data))
+							{
+								if(lstrcmpiA((LPCSTR)data, "WINNT") == 0)
+								{
+									productType = 1;
+								}
+								else if (lstrcmpiA((LPCSTR)data, "LANMANNT") == 0)
+								{
+									productType = 2;
+								}
+								else if (lstrcmpiA((LPCSTR)data, "SERVERNT") == 0)
+								{
+									productType = 3;
+								}
+
+								LocalUnlock(data);
+								data = NULL;
+								LocalFree(dataHandle);
+								dataHandle = 0;
+							}
+						}
+
+						if(hKeyCurrentVersion != 0)
+						{
+							RegCloseKey(hKeyCurrentVersion);
+						}
+
+						if(hKeyProductOptions != 0)
+						{
+							RegCloseKey(hKeyProductOptions);
+						}
+
+						wProductType = productType;
+
+						zVersionInfoSet = TRUE;
+					}
+				}
+
+				if(!success && fpGetVersionEx != NULL)
+				{
+					LOSVERSIONINFOA versionInformation;
+					memset(&versionInformation, '\0', sizeof (LOSVERSIONINFOA));
+					versionInformation.dwOSVersionInfoSize = sizeof (LOSVERSIONINFOA);
+					success = ((LPGetVersionEXA)fpGetVersionEx)(&versionInformation);
+					if(success)
+					{
+						HKEY hKeyCurrentVersion = 0;
+						HKEY hKeyProductOptions = 0;
+
+						/* for win32S, GetVersionEx returns the version of win32s, so a separate call to GetVersion will be required. */
+						if(zIsWin32s || versionInformation.dwMajorVersion < 3)
+						{
+							DWORD dwVersion = GetVersion();
+
+							majorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));
+							minorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion)));
+
+							build = 0;
+							if(dwVersion < 0x80000000)
+							{
+								build = (DWORD)(HIWORD(dwVersion));
+							}
+
+							platformId = 0;
+						}
+						else
+						{
+							majorVersion = versionInformation.dwMajorVersion;
+							minorVersion = versionInformation.dwMinorVersion;
+							build = versionInformation.dwBuildNumber;
+							platformId = versionInformation.dwPlatformId;
+						}
+
+						dwMajorVersion = majorVersion;
+						dwMinorVersion = minorVersion;
+						dwBuild = build;
+						dwPlatformId = platformId;
+						productType = 0;
+
+						GetWindowsRegistryKey(&hKeyCurrentVersion, &hKeyProductOptions);
+
+						if(productType == 0 && hKeyCurrentVersion != 0)
+						{
+							HLOCAL dataHandle = NULL;
+							LPBYTE data;
+
+							if(ReadWindowsRegistryValue(&hKeyCurrentVersion, "ProductType", &dataHandle, &data))
+							{
+								productType = mytob((LPSTR)data);
+
+								LocalUnlock(data);
+								data = NULL;
+								LocalFree(dataHandle);
+								dataHandle = 0;
+							}
+						}
+						if(productType == 0 && hKeyProductOptions != 0)
+						{
+							HLOCAL dataHandle = NULL;
+							LPBYTE data;
+
+							if(ReadWindowsRegistryValue(&hKeyProductOptions, "ProductType", &dataHandle, &data))
+							{
+								if(lstrcmpiA((LPCSTR)data, "WINNT") == 0)
+								{
+									productType = 1;
+								}
+								else if (lstrcmpiA((LPCSTR)data, "LANMANNT") == 0)
+								{
+									productType = 2;
+								}
+								else if (lstrcmpiA((LPCSTR)data, "SERVERNT") == 0)
+								{
+									productType = 3;
+								}
+
+								LocalUnlock(data);
+								data = NULL;
+								LocalFree(dataHandle);
+								dataHandle = 0;
+							}
+						}
+
+						if(hKeyCurrentVersion != 0)
+						{
+							RegCloseKey(hKeyCurrentVersion);
+						}
+
+						if(hKeyProductOptions != 0)
+						{
+							RegCloseKey(hKeyProductOptions);
+						}
+
+						wProductType = productType;
+
+						zVersionInfoSet = TRUE;
+					}
+				}
+
+				if(!success)
+				{
+					HKEY hKeyCurrentVersion = 0;
+					HKEY hKeyProductOptions = 0;
+					DWORD dwVersion = 0;
+					BOOL isNT = FALSE;
+
+					dwVersion = GetVersion();
+
+					majorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));
+					minorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion)));
+
+					if(dwVersion < 0x80000000)
+					{
+						build = (DWORD)(HIWORD(dwVersion));
+
+						dwBuild = build;
+					}
+
+					productType = 0;
+
+					platformId = 0;
+
+					dwMajorVersion = majorVersion;
+					dwMinorVersion = minorVersion;
+
+					GetWindowsRegistryKey(&hKeyCurrentVersion, &hKeyProductOptions);
+
+					if(productType == 0 && hKeyCurrentVersion != 0)
+					{
+						HLOCAL dataHandle = NULL;
+						LPBYTE data;
+
+						if(ReadWindowsRegistryValue(&hKeyCurrentVersion, "ProductType", &dataHandle, &data))
+						{
+							productType = mytob((LPSTR)data);
+
+							LocalUnlock(data);
+							data = NULL;
+							LocalFree(dataHandle);
+							dataHandle = 0;
+						}
+					}
+					if(productType == 0 && hKeyProductOptions != 0)
+					{
+						HLOCAL dataHandle = NULL;
+						LPBYTE data;
+
+						if(ReadWindowsRegistryValue(&hKeyProductOptions, "ProductType", &dataHandle, &data))
+						{
+							isNT = TRUE;
+							if(lstrcmpiA((LPCSTR)data, "WINNT") == 0)
+							{
+								productType = 1;
+							}
+							else if (lstrcmpiA((LPCSTR)data, "LANMANNT") == 0)
+							{
+								productType = 2;
+							}
+							else if (lstrcmpiA((LPCSTR)data, "SERVERNT") == 0)
+							{
+								productType = 3;
+							}
+
+							LocalUnlock(data);
+							data = NULL;
+							LocalFree(dataHandle);
+							dataHandle = 0;
+						}
+					}
+
+					if(hKeyCurrentVersion != 0)
+					{
+						RegCloseKey(hKeyCurrentVersion);
+					}
+
+					if(hKeyProductOptions != 0)
+					{
+						RegCloseKey(hKeyProductOptions);
+					}
+
+					wProductType = productType;
+
+					if(dwMajorVersion >= 3 && dwMinorVersion == 0x0a && zIsWin32s)
+					{
+						platformId = 0;
+					}
+					else if(dwMajorVersion >= 3 && (dwMinorVersion == 0x0a || dwMinorVersion == 0x32 || dwMinorVersion == 0x33))
+					{
+						platformId = 2;
+					}
+					else if(dwMajorVersion >= 4 && isNT)
+					{
+						platformId = 2;
+					}
+					else if(dwMajorVersion >= 4)
+					{
+						platformId = 1;
+					}
+					else
+					{
+						platformId = 0;
+					}
+					dwPlatformId = platformId;
+
+					zVersionInfoSet = TRUE;
+				}
+
+				isNT = zIsNt;
+				isWin32s = zIsWin32s;
+				processorArchitecture = ((PLSYSTEM_INFO)(&systemInfo))->DUMMYUNION.DUMMYSTRUCT.wProcessorArchitecture;
+			}
+			else
+			{
+				majorVersion = dwMajorVersion;
+				minorVersion = dwMinorVersion;
+				build = dwBuild;
+				platformId = dwPlatformId;
+				productType = wProductType;
+
+				isNT = zIsNt;
+				isWin32s = zIsWin32s;
+				processorArchitecture = ((PLSYSTEM_INFO)(&systemInfo))->DUMMYUNION.DUMMYSTRUCT.wProcessorArchitecture;
+			}
+		}
+
+		static void GetPhysicalMemory(LPLMEMORYSTATUSEX status)
+		{
+			BOOL success = FALSE;
+			if(!success && fpGlobalMemoryStatusEx != NULL)
+			{
+				LMEMORYSTATUSEX memStatus;
+				memset(&memStatus, '\0', sizeof (memStatus));
+				memStatus.dwLength = sizeof (memStatus);
+
+				success = ((LPGlobalMemoryStatusEX)(fpGlobalMemoryStatusEx))(&memStatus);
+
+				if(success)
+				{
+					*status = memStatus;
+				}
+			}
+			if(!success && fpGlobalMemoryStatus != NULL)
+			{
+				MEMORYSTATUS memStatus;
+				memset(&memStatus, '\0', sizeof (memStatus));
+				memStatus.dwLength = sizeof (memStatus);
+
+				((LPGlobalMemoryStatus)(fpGlobalMemoryStatus))(&memStatus);
+				success = TRUE;
+				if(success)
+				{
+					status->dwLength = memStatus.dwLength;
+					status->dwMemoryLoad = memStatus.dwMemoryLoad;
+					status->ullTotalPhys = memStatus.dwTotalPhys;
+					status->ullAvailPhys = memStatus.dwAvailPhys;
+					status->ullTotalPageFile = memStatus.dwTotalPageFile;
+					status->ullAvailPageFile = memStatus.dwAvailPageFile;
+					status->ullTotalVirtual = memStatus.dwTotalVirtual;
+					status->ullAvailVirtual = memStatus.dwAvailVirtual;
+					status->ullAvailExtendedVirtual = 0;
+				}
+			}
+			if(!success)
+			{
+				ZeroMemory(&status, sizeof (LMEMORYSTATUSEX));
+			}
+		}
+
+		~GetWindowsInfo()
+		{
+			numInstances--;
+			if(numInstances == 0)
+			{
+				if(hNtDll != 0)
+				{
+					FreeLibrary(hNtDll);
+					hNtDll = 0;
+				}
+
+				if(hKernel32 != 0)
+				{
+					FreeLibrary(hKernel32);
+					hKernel32 = 0;
+				}
+
+				if(hAdvapi32 != 0)
+				{
+					FreeLibrary(hAdvapi32);
+					hAdvapi32 = 0;
+				}
+
+				fpGetVersionEx = NULL;
+				fpRtlGetVersion = NULL;
+				fpGlobalMemoryStatusEx = NULL;
+				fpGlobalMemoryStatus = NULL;
+				fpRegOpenKeyExA = NULL;
+				fpRegQueryValueExA = NULL;
+			}
+		}
+
+		/* The following functio was copied, and editted from Boehm-Demers-Weiser conservative C/C++ Garbage Collector os_dep.c.
+		 * This copy was done due to VirtualQuery not working the same in win32S. So this function uses a static global variable, instead,
+		 * to pull memory.
+		 * As such:
+		 */
+		/*
+		 * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers
+		 * Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.
+		 * Copyright (c) 1996-1999 by Silicon Graphics.  All rights reserved.
+		 * Copyright (c) 1999 by Hewlett-Packard Company.  All rights reserved.
+		 *
+		 * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED
+		 * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.
+		 *
+		 * Permission is hereby granted to use or copy this program
+		 * for any purpose,  provided the above notices are retained on all copies.
+		 * Permission to modify the code and to distribute modified code is granted,
+		 * provided the above notices are retained, and a notice that the code was
+		 * modified is included with the above copyright notice.
+		 */
+		/* Return the smallest address a such that VirtualQuery               */
+		/* returns correct results for all addresses between a and start.     */
+		/* Assumes VirtualQuery returns correct information for start.        */
+		static LPVOID GC_least_described_address(LPVOID start)
+		{
+			MEMORY_BASIC_INFORMATION buf;
+			LPVOID limit;
+			LPVOID p;
+
+			limit = systemInfo.lpMinimumApplicationAddress;
+			#ifdef _WIN64
+			p = (LPVOID)((QWORD)start & ~(systemInfo.dwPageSize - 1));
+			#else
+			p = (LPVOID)((DWORD)start & ~(systemInfo.dwPageSize - 1));
+			#endif
+			for (;;) {
+				size_t result;
+				#ifdef _WIN64
+				LPVOID q = (LPVOID)((QWORD)p - systemInfo.dwPageSize);
+				#else
+				LPVOID q = (LPVOID)((DWORD)p - systemInfo.dwPageSize);
+				#endif
+
+				#ifdef _WIN64
+				if ((QWORD)q > (QWORD)p /* underflow */ || (QWORD)q < (QWORD)limit) break;
+				#else
+				if ((DWORD)q > (DWORD)p /* underflow */ || (DWORD)q < (DWORD)limit) break;
+				#endif
+				result = VirtualQuery(q, &buf, sizeof(buf));
+				if (result != sizeof(buf) || buf.AllocationBase == 0) break;
+				p = (LPVOID)(buf.AllocationBase);
+			}
+			return p;
+		}
+
+		static size_t GetStackUsage()
+		{
+			if(!zStackUsageSet)
+			{
+				LPVOID AllocationBase;
+				MEMORY_BASIC_INFORMATION mbi;
+				if(!zIsWin32s)
+				{
+					VirtualQuery(&mbi, &mbi, sizeof(mbi));
+					AllocationBase = mbi.AllocationBase;
+				}
+				else
+				{
+					AllocationBase = GC_least_described_address(&zIsWin32s);
+				}
+				// now mbi.AllocationBase = reserved stack memory base address
+
+				VirtualQuery(AllocationBase, &mbi, sizeof(mbi));
+				// now (mbi.BaseAddress, mbi.RegionSize) describe reserved (uncommitted) portion of the stack
+				// skip it
+
+				VirtualQuery((char*)mbi.BaseAddress + mbi.RegionSize, &mbi, sizeof(mbi));
+				// now (mbi.BaseAddress, mbi.RegionSize) describe the guard page
+				// skip it
+
+				VirtualQuery((char*)mbi.BaseAddress + mbi.RegionSize, &mbi, sizeof(mbi));
+				// now (mbi.BaseAddress, mbi.RegionSize) describe the committed (i.e. accessed) portion of the stack
+
+				zStackUsage = mbi.RegionSize;
+				zStackUsageSet = TRUE;
+			}
+			return zStackUsage;
+		}
+
+		static void GetWindowsSystemInfo(PLSYSTEM_INFO FAR * pSystemInfo)
+		{
+			if(!zSetSystemInfo)
+			{
+				GetSystemInfo(&systemInfo);
+				zSetSystemInfo = TRUE;
+			}
+			*pSystemInfo = ((PLSYSTEM_INFO)(&systemInfo));
+		}
+};
+
+int GetWindowsInfo::numInstances = 0;
+FARPROC GetWindowsInfo::fpGetVersionEx = NULL;
+FARPROC GetWindowsInfo::fpRtlGetVersion = NULL;
+FARPROC GetWindowsInfo::fpGlobalMemoryStatusEx = NULL;
+FARPROC GetWindowsInfo::fpGlobalMemoryStatus = NULL;
+FARPROC GetWindowsInfo::fpRegOpenKeyExA = NULL;
+FARPROC GetWindowsInfo::fpRegQueryValueExA = NULL;
+HMODULE GetWindowsInfo::hKernel32 = 0;
+HMODULE GetWindowsInfo::hAdvapi32 = 0;
+HMODULE GetWindowsInfo::hNtDll = 0;
+size_t GetWindowsInfo::zStackUsage = 0;
+BOOL GetWindowsInfo::zStackUsageSet = FALSE;
+BOOL GetWindowsInfo::zVersionInfoSet = FALSE;
+DWORD GetWindowsInfo::dwMajorVersion = 0;
+DWORD GetWindowsInfo::dwMinorVersion = 0;
+DWORD GetWindowsInfo::dwBuild = 0;
+DWORD GetWindowsInfo::dwPlatformId = 0;
+BYTE GetWindowsInfo::wProductType = 0;
+BOOL GetWindowsInfo::zIsNt = FALSE;
+BOOL GetWindowsInfo::zIsWin32s = FALSE;
+SYSTEM_INFO GetWindowsInfo::systemInfo;
+BOOL GetWindowsInfo::zSetSystemInfo = FALSE;
+
+static GetWindowsInfo _getWindowsInfo;
+
+static DWORD dWordnumberOfSetBits(DWORD i)
+{
+     // Java: use >>> instead of >>
+     // C or C++: use uint32_t
+     i = i - ((i >> 1) & 0x55555555);
+     i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
+     return (((i + (i >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
+}
+
+/*static WORD wordnumberOfSetBits(WORD i)
+{
+     // Java: use >>> instead of >>
+     // C or C++: use uint32_t
+     i = i - ((i >> 1) & 0x5555);
+     i = (i & 0x3333) + ((i >> 2) & 0x3333);
+     i = (((i + (i >> 4)) & 0x0F0F) * 0x0101);
+     return i >> 8;
+}
+
+static BYTE bytenumberOfSetBits(BYTE i)
+{
+     // Java: use >>> instead of >>
+     // C or C++: use uint32_t
+     i = i - ((i >> 1) & 0x55);
+     i = (i & 0x33) + ((i >> 2) & 0x33);
+     i = (((i + (i >> 4)) & 0x0F) * 0x01);
+     return i;
+}*/
+
+
+#define _SC_ARG_MAX 0
+#define _SC_CHILD_MAX 1
+#define _SC_CLK_TCK 2
+#define _SC_NGROUPS_MAX 3
+#define _SC_OPEN_MAX 4
+#define _SC_STREAM_MAX 5
+#define _SC_TZNAME_MAX 6
+#define _SC_VERSION 29
+#define _SC_PAGESIZE 30
+#define _SC_PAGE_SIZE 30
+#define _SC_BC_BASE_MAX 36
+#define _SC_BC_DIM_MAX 37
+#define _SC_BC_SCALE_MAX 38
+#define _SC_BC_STRING_MAX 39
+#define _SC_COLL_WEIGHTS_MAX 40
+#define _SC_EXPR_NEST_MAX 42
+#define _SC_LINE_MAX 43
+#define _SC_RE_DUP_MAX 44
+#define _SC_2_VERSION 46
+#define _SC_2_C_DEV 48
+#define _SC_2_FORT_DEV 49
+#define _SC_2_FORT_RUN 50
+#define _SC_2_SW_DEV 51
+#define _SC_2_LOCALEDEF 52
+#define _SC_LOGIN_NAME_MAX 71
+#define _SC_TTY_NAME_MAX 72
+#define _SC_NPROCESSORS_CONF 83
+#define _SC_NPROCESSORS_ONLN 84
+#define _SC_PHYS_PAGES 85
+#define _SC_AVPHYS_PAGES 86
+#define _SC_SYMLOOP_MAX 173
+#define _SC_HOST_NAME_MAX 180
+
+long sysconf(int name)
+{
+        long retVal;
+
+        switch(name)
+        {
+			case _SC_ARG_MAX:
+				{
+					// 64 - 1 max < windows 2000
+					// 1020 - 1 max = windows NT 3.51, NT 4.0 Workstation
+					// 1024 - 1 max = windows 2000
+					// 4096 - 1 >= windows XP
+					//retVal = ARG_MAX;
+					DWORD dwMinorVersion;
+					DWORD dwMajorVersion;
+					DWORD dwBuild;
+					DWORD dwPlatformId;
+					BYTE wProductType;
+					BOOL zIsNt;
+					BOOL zIsWin32s;
+					WORD wProcessorArchitecture;
+
+					GetWindowsInfo::GetWindowsVersion(dwMinorVersion, dwMajorVersion, dwBuild, dwPlatformId, wProductType, zIsNt, zIsWin32s, wProcessorArchitecture);
+
+					//508 - 1 for NT 3.1
+					if(dwMajorVersion == 3 && dwMinorVersion == 0x0a && zIsWin32s)
+					{
+						retVal = 64 - 1;
+					}
+					else if(dwMajorVersion == 3 && (dwMinorVersion == 0x0a || dwMinorVersion == 0x32))
+					{
+						retVal = 508 - 1;
+					}
+					else if(dwMajorVersion == 3 && dwMinorVersion == 0x33)
+					{
+						retVal = 1020 - 1;
+					}
+					else if((dwMajorVersion == 4 && dwMinorVersion == 0 && dwPlatformId == 2) || (dwMajorVersion == 5 && dwMinorVersion == 0))
+					{
+						retVal = 1024 - 1;
+					}
+					else if(dwMajorVersion < 5)
+					{
+						retVal = 64 - 1;
+					}
+					else
+					{
+						retVal = 4096 - 1;
+					}
+				}
+				break;
+			case _SC_CHILD_MAX:
+				{
+					// get the amount of committed memory.
+					// this is normally limited only by physical memory and the amount used by the stack
+					// except in windows 9X where FS is shared for all processes so there is an additional
+					// 8192 limit.
+					// if we fail to get the stack usage, for some reason then use POSIX minimum of 25
+					DWORD dwMinorVersion;
+					DWORD dwMajorVersion;
+					DWORD dwBuild;
+					DWORD dwPlatformId;
+					BYTE wProductType;
+					BOOL zIsNt;
+					BOOL zIsWin32s;
+					WORD wProcessorArchitecture;
+					LMEMORYSTATUSEX status;
+					DWORDLONG maxChildren;
+					size_t stackUsage;
+					GetWindowsInfo::GetPhysicalMemory(&status);
+
+					stackUsage = GetWindowsInfo::GetStackUsage();
+					maxChildren = (stackUsage != 0) ? status.ullTotalPhys / stackUsage : 25;
+
+					GetWindowsInfo::GetWindowsVersion(dwMinorVersion, dwMajorVersion, dwBuild, dwPlatformId, wProductType, zIsNt, zIsWin32s, wProcessorArchitecture);
+
+					if(dwMajorVersion < 3 || zIsWin32s || (dwMajorVersion == 3 && dwMinorVersion != 0x0a && dwMinorVersion != 0x32 && dwMinorVersion != 0x33) || (dwMajorVersion == 4 && (dwMinorVersion != 0 || dwPlatformId != 2)))
+					{
+						if(maxChildren == 0 || maxChildren > 8192)
+						{
+							maxChildren = 8192;
+						}
+					}
+
+					if(maxChildren > LONG_MAX)
+						maxChildren = LONG_MAX;
+
+					retVal = (long)maxChildren;
+				}
+				break;
+			case _SC_HOST_NAME_MAX:
+				{
+					retVal = 256;
+				}
+				break;
+			case _SC_LOGIN_NAME_MAX:
+				{
+					retVal = UNLEN + 1;
+				}
+				break;
+			case _SC_NGROUPS_MAX:
+				{
+					retVal = 1024;
+				}
+				break;
+			case _SC_CLK_TCK:
+				{
+					retVal = CLK_TCK;
+				}
+				break;
+			case _SC_OPEN_MAX:
+				{
+					// found experimentally:
+					// Win 32s: 27 (512 MB memory, 243MB swap file)
+					// NT 3.1: 4033 (64 MB memory, 999MB Swap file)
+					// NT 3.5: 30676 (1024 MB memory 4000MB Swap File)
+					// NT 3.51: 32403 (3.5GB, 3.5GB Swap File)
+					// NT 4.0: 30069 (4.0GB, 3949MB Swap file)
+					// NT 4.0 33013 (4.0GB, system swap file)
+					// windows 95: 64967 (512MB memory, 2G swap file)
+					// windows 98: 22527 (1GB memory, 4GB swap file)
+					// windows ME: 20443 (1GB memory, 4GB swap file)
+					// windows 2k: 300832 (4GB memory, 4GB swap file)
+					// windows XP SP2 32bit: 324530 (4GB memory, 4GB swap file)
+					// windows XP SP1 64bit: 2550445 (4GB memory, 4GB swap file)
+					// vista 32:895257 (8GB memory, 4GB swap file)
+					// vista >3.55 million (8GB memory, ??? GB swap file)
+					// 7 32: 764274 (8GB memory, system swap file)
+					// 8 32: 663377 (8GB memory, system swap file)
+					// 8.1 32: 651039 (8GB memory, system swap file)
+					// 10 32: 524637 (8GB memory, system swap file)
+					// windows 2k3: 272253 (6GB memory, system picked swap)
+					// windows 2k8 datacenter 32: 514542 (13.3GB memory, system picked swap)
+					// TODO: windows 1.x, 2.x, 3.x, 64bit other then windows XP
+
+					DWORD dwMinorVersion;
+					DWORD dwMajorVersion;
+					DWORD dwBuild;
+					DWORD dwPlatformId;
+					BYTE wProductType;
+					BOOL zIsNt;
+					BOOL zIsWin32s;
+					WORD wProcessorArchitecture;
+
+					GetWindowsInfo::GetWindowsVersion(dwMinorVersion, dwMajorVersion, dwBuild, dwPlatformId, wProductType, zIsNt, zIsWin32s, wProcessorArchitecture);
+
+					switch(dwMajorVersion)
+					{
+						case 3:
+							switch(dwMinorVersion)
+							{
+								case 0x0a:
+									// WIN 3.11 (WIN32s)
+									if(zIsWin32s)
+									{
+										retVal = 27;
+									}
+									// NT 3.1
+									else
+									{
+										retVal = 4033;
+									}
+									break;
+								// NT 3.5
+								case 0x32:
+									retVal = 30676;
+									break;
+								// NT 3.51
+								case 0x33:
+									retVal = 32403;
+									break;
+								default:
+									retVal = -1;
+									errno = EINVAL;
+									break;
+							}
+							break;
+						case 4:
+							{
+								switch(dwMinorVersion)
+								{
+									// WIN 95 and NT 4
+									case 0:
+										switch(dwPlatformId)
+										{
+											// NT 4
+											case 2:
+												retVal = 30069;
+												break;
+											// WIN 95
+											default:
+												retVal = 64967;
+												break;
+										}
+										break;
+									// WIN 98
+									case 0x0a:
+										retVal = 22527;
+										break;
+									// WIN ME
+									case 0x5a:
+										retVal = 20443;
+										break;
+									default:
+										retVal = -1;
+										errno = EINVAL;
+								}
+							}
+							break;
+						case 5:
+							{
+								switch(dwMinorVersion)
+								{
+									// WIN 20000
+									case 0:
+										retVal = 300832;
+										break;
+									// WIN XP
+									case 1:
+										retVal = 324530;
+										break;
+									// WIN XP 64 and 2003
+									case 2:
+										switch(wProductType)
+										{
+											case 1:
+												// XP
+												retVal = 2550445;
+												break;
+											default:
+												// 2003
+												switch(wProcessorArchitecture)
+												{
+													// x86
+													case 0:
+														retVal = 272253;
+														break;
+													// x64
+													default:
+														retVal = -1;
+														errno = EINVAL;
+														break;
+												}
+												break;
+										}
+										break;
+								}
+							}
+							break;
+						case 6:
+							{
+								switch(dwMinorVersion)
+								{
+									// Vista, 2008
+									case 0:
+										switch(wProductType)
+										{
+											case 1:
+												// VISTA
+												switch(wProcessorArchitecture)
+												{
+													// x86
+													case 0:
+														retVal = 895257;
+														break;
+													// x64
+													default:
+														retVal = -1;
+														errno = EINVAL;
+														break;
+												}
+												break;
+											default:
+												// 2008
+												switch(wProcessorArchitecture)
+												{
+													// x86
+													case 0:
+														retVal = 514542;
+														errno = EINVAL;
+														break;
+													// x64
+													default:
+														retVal = -1;
+														errno = EINVAL;
+														break;
+												}
+												break;
+										}
+										break;
+									// 7, 2008 R2
+									case 1:
+										switch(wProductType)
+										{
+											case 1:
+												// 7
+												switch(wProcessorArchitecture)
+												{
+													// x86
+													case 0:
+														retVal = 764274;
+														errno = EINVAL;
+														break;
+													// x64
+													default:
+														retVal = -1;
+														errno = EINVAL;
+														break;
+												}
+												break;
+											default:
+												// 2008 R2
+												switch(wProcessorArchitecture)
+												{
+													// x86
+													case 0:
+														retVal = -1;
+														errno = EINVAL;
+														break;
+													// x64
+													default:
+														retVal = -1;
+														errno = EINVAL;
+														break;
+												}
+												break;
+										}
+										break;
+									// 8, 2012
+									case 2:
+										switch(wProductType)
+										{
+											case 1:
+												// 8
+												switch(wProcessorArchitecture)
+												{
+													// x86
+													case 0:
+														retVal = 663377;
+														errno = EINVAL;
+														break;
+													// x64
+													default:
+														retVal = -1;
+														errno = EINVAL;
+														break;
+												}
+												break;
+											default:
+												// 2012
+												switch(wProcessorArchitecture)
+												{
+													// x86
+													case 0:
+														retVal = -1;
+														errno = EINVAL;
+														break;
+													// x64
+													default:
+														retVal = -1;
+														errno = EINVAL;
+														break;
+												}
+												break;
+										}
+										break;
+									// 8.1, 2012 R2
+									case 3:
+										switch(wProductType)
+										{
+											case 1:
+												// 8.1
+												switch(wProcessorArchitecture)
+												{
+													// x86
+													case 0:
+														retVal = 651039;
+														errno = EINVAL;
+														break;
+													// x64
+													default:
+														retVal = -1;
+														errno = EINVAL;
+														break;
+												}
+												break;
+											default:
+												// 2012 R2
+												switch(wProcessorArchitecture)
+												{
+													// x86
+													case 0:
+														retVal = -1;
+														errno = EINVAL;
+														break;
+													// x64
+													default:
+														retVal = -1;
+														errno = EINVAL;
+														break;
+												}
+												break;
+										}
+										break;
+								}
+							}
+							break;
+						case 10:
+							{
+								switch(dwMinorVersion)
+								{
+									// 10, 2016
+									case 0:
+										switch(wProductType)
+										{
+											case 1:
+												// 10
+												switch(wProcessorArchitecture)
+												{
+													// x86
+													case 0:
+														retVal = 524637;
+														break;
+													// x64
+													default:
+														retVal = -1;
+														errno = EINVAL;
+														break;
+												}
+												break;
+											default:
+												// 2016
+												switch(wProcessorArchitecture)
+												{
+													// x86
+													case 0:
+														retVal = -1;
+														errno = EINVAL;
+														break;
+													// x64
+													default:
+														retVal = -1;
+														errno = EINVAL;
+														break;
+												}
+												break;
+										}
+										break;
+								}
+							}
+							break;
+						default:
+							retVal = -1;
+							errno = EINVAL;
+							break;
+					}
+				}
+				break;
+#if _SC_PAGESIZE != _SC_PAGE_SIZE
+			case _SC_PAGESIZE:
+#endif
+			case _SC_PAGE_SIZE:
+				PLSYSTEM_INFO pSystemInfo;
+				GetWindowsInfo::GetWindowsSystemInfo(&pSystemInfo);
+				retVal = pSystemInfo->dwPageSize;
+				break;
+			case _SC_RE_DUP_MAX:
+				retVal = RE_DUP_MAX;
+				break;
+			case _SC_STREAM_MAX:
+				#if defined(_MSC_VER)
+					#if (_MSC_VER >= 1000)
+						retVal = _getmaxstdio();
+					#else
+						retVal = 512;
+					#endif
+				#else
+					retVal = _getmaxstdio();
+				#endif
+				break;
+			case _SC_SYMLOOP_MAX:
+				retVal = SYMLOOP_MAX;
+				break;
+			case _SC_TTY_NAME_MAX:
+				{
+					DWORD dwMinorVersion;
+					DWORD dwMajorVersion;
+					DWORD dwBuild;
+					DWORD dwPlatformId;
+					BYTE wProductType;
+					BOOL zIsNt;
+					BOOL zIsWin32s;
+					WORD wProcessorArchitecture;
+
+					GetWindowsInfo::GetWindowsVersion(dwMinorVersion, dwMajorVersion, dwBuild, dwPlatformId, wProductType, zIsNt, zIsWin32s, wProcessorArchitecture);
+
+					if(dwMajorVersion >= 4)
+						retVal = MAX_PATH;
+					else
+						retVal = 12;
+				}
+				break;
+			case _SC_TZNAME_MAX:
+				TIME_ZONE_INFORMATION tzInfo;
+				retVal = MAX(sizeof tzInfo.StandardName / sizeof tzInfo.StandardName[0], sizeof tzInfo.DaylightName / sizeof tzInfo.DaylightName[0]) - 1;
+				break;
+			case _SC_VERSION:
+				retVal = 198801L;
+				break;
+			case _SC_BC_BASE_MAX:
+				retVal = 99; // shamelessly stolen from Linux as Windows doesn't have BC separate from GnuWin32 Project
+				break;
+			case _SC_BC_DIM_MAX:
+				retVal = 2048; // shamelessly stolen from Linux as Windows doesn't have BC separate from GnuWin32 Project
+				break;
+			case _SC_BC_SCALE_MAX:
+				retVal = 99; // shamelessly stolen from Linux as Windows doesn't have BC separate from GnuWin32 Project
+				break;
+			case _SC_BC_STRING_MAX:
+				retVal = 1000; // shamelessly stolen from Linux as Windows doesn't have BC separate from GnuWin32 Project
+				break;
+			case _SC_COLL_WEIGHTS_MAX:
+				retVal = COLL_WEIGHTS_MAX;
+				break;
+			case _SC_EXPR_NEST_MAX:
+				retVal = 32; // shamelessly stolen from Linux as Windows doesn't have expr separate from GnuWin32 Project
+				break;
+			case _SC_LINE_MAX:
+				{
+					// 64 - 1 max < windows 2000
+					// 1020 - 1 max = windows NT 3.51, NT 4.0 Workstation
+					// 1024 - 1 max = windows 2000
+					// 4096 - 1 >= windows XP
+					//retVal = ARG_MAX;
+					DWORD dwMinorVersion;
+					DWORD dwMajorVersion;
+					DWORD dwBuild;
+					DWORD dwPlatformId;
+					BYTE wProductType;
+					BOOL zIsNt;
+					BOOL zIsWin32s;
+					WORD wProcessorArchitecture;
+
+					GetWindowsInfo::GetWindowsVersion(dwMinorVersion, dwMajorVersion, dwBuild, dwPlatformId, wProductType, zIsNt, zIsWin32s, wProcessorArchitecture);
+
+					// Win 3.11
+					if(dwMajorVersion == 3 && dwMinorVersion == 0x0a && zIsWin32s)
+					{
+						retVal = 126;
+					}
+					// NT 3.1 and NT 3.5
+					else if(dwMajorVersion == 3 && (dwMinorVersion == 0x0a || dwMinorVersion == 0x32))
+					{
+						retVal = 1023;
+					}
+					// NT 3.51, NT 4.0, and Windows 2000
+					else if((dwMajorVersion == 3 && dwMinorVersion == 0x33) || (dwMajorVersion == 4 && dwMinorVersion == 0 && dwPlatformId == 2) || (dwMajorVersion == 5 && dwMinorVersion == 0))
+					{
+						retVal = 2047;
+					}
+					// Win 9x
+					else if(dwMajorVersion < 5)
+					{
+						retVal = 126;
+					}
+					else
+					{
+						retVal = 8191;
+					}
+				}
+				break;
+			case _SC_2_VERSION:
+				retVal = 198801L;
+				break;
+			case _SC_2_C_DEV:
+				retVal = 0L;
+				break;
+			case _SC_2_FORT_DEV:
+				retVal = 0L;
+				break;
+			case _SC_2_FORT_RUN:
+				retVal = 0L;
+				break;
+			case _SC_2_LOCALEDEF:
+				retVal = 0L;
+				break;
+			case _SC_2_SW_DEV:
+				retVal = 0L;
+				break;
+			case _SC_PHYS_PAGES:
+				{
+					DWORDLONG res;
+					LMEMORYSTATUSEX status;
+					PLSYSTEM_INFO pSystemInfo;
+
+					GetWindowsInfo::GetPhysicalMemory(&status);
+					GetWindowsInfo::GetWindowsSystemInfo(&pSystemInfo);
+
+					res = ((status.ullTotalPhys + (pSystemInfo->dwPageSize - 1)) / pSystemInfo->dwPageSize);
+					//res = (status.ullTotalPhys / pSystemInfo->dwPageSize) + (status.ullTotalPhys % pSystemInfo->dwPageSize != 0);
+					retVal = (res > LONG_MAX) ? LONG_MAX : (long)res;
+				}
+				break;
+			case _SC_AVPHYS_PAGES:
+				{
+					DWORDLONG res;
+					LMEMORYSTATUSEX status;
+					PLSYSTEM_INFO pSystemInfo;
+
+					GetWindowsInfo::GetPhysicalMemory(&status);
+					GetWindowsInfo::GetWindowsSystemInfo(&pSystemInfo);
+
+					res = ((status.ullAvailPhys + (pSystemInfo->dwPageSize - 1)) / pSystemInfo->dwPageSize);
+					//res = (status.ullAvailPhys / pSystemInfo->dwPageSize) + (status.ullAvailPhys % pSystemInfo->dwPageSize != 0);
+					retVal = (res > LONG_MAX) ? LONG_MAX : (long)res;
+				}
+				break;
+			case _SC_NPROCESSORS_CONF:
+				{
+					PLSYSTEM_INFO pSystemInfo;
+
+					GetWindowsInfo::GetWindowsSystemInfo(&pSystemInfo);
+
+					retVal = pSystemInfo->dwNumberOfProcessors;
+				}
+				break;
+			case _SC_NPROCESSORS_ONLN:
+				{
+					PLSYSTEM_INFO pSystemInfo;
+
+					GetWindowsInfo::GetWindowsSystemInfo(&pSystemInfo);
+
+					retVal = dWordnumberOfSetBits(pSystemInfo->dwActiveProcessorMask);
+				}
+				break;
+			default:
+				retVal = -1;
+				errno = EINVAL;
+				break;
+        }
+
+        return retVal;
+}
+
diff -Naur Retro68.old/libelf/src/sysconf.h Retro68/libelf/src/sysconf.h
--- Retro68.old/libelf/src/sysconf.h	1969-12-31 16:00:00.000000000 -0800
+++ Retro68/libelf/src/sysconf.h	2020-05-01 20:17:30.091932104 -0700
@@ -0,0 +1,39 @@
+#ifndef INCLUDE_SYSCONF_H
+#define INCLUDE_SYSCONF_H
+
+#define _SC_ARG_MAX 0
+#define _SC_CHILD_MAX 1
+#define _SC_CLK_TCK 2
+#define _SC_NGROUPS_MAX 3
+#define _SC_OPEN_MAX 4
+#define _SC_STREAM_MAX 5
+#define _SC_TZNAME_MAX 6
+#define _SC_VERSION 29
+#define _SC_PAGESIZE 30
+#define _SC_PAGE_SIZE 30
+#define _SC_BC_BASE_MAX 36
+#define _SC_BC_DIM_MAX 37
+#define _SC_BC_SCALE_MAX 38
+#define _SC_BC_STRING_MAX 39
+#define _SC_COLL_WEIGHTS_MAX 40
+#define _SC_EXPR_NEST_MAX 42
+#define _SC_LINE_MAX 43
+#define _SC_RE_DUP_MAX 44
+#define _SC_2_VERSION 46
+#define _SC_2_C_DEV 48
+#define _SC_2_FORT_DEV 49
+#define _SC_2_FORT_RUN 50
+#define _SC_2_SW_DEV 51
+#define _SC_2_LOCALEDEF 52
+#define _SC_LOGIN_NAME_MAX 71
+#define _SC_TTY_NAME_MAX 72
+#define _SC_NPROCESSORS_CONF 83
+#define _SC_NPROCESSORS_ONLN 84
+#define _SC_PHYS_PAGES 85
+#define _SC_AVPHYS_PAGES 86
+#define _SC_SYMLOOP_MAX 173
+#define _SC_HOST_NAME_MAX 180
+
+long sysconf(int name);
+
+#endif
diff -Naur Retro68.old/libelf/src/system.h Retro68/libelf/src/system.h
--- Retro68.old/libelf/src/system.h	2020-03-19 19:23:50.025534162 -0700
+++ Retro68/libelf/src/system.h	2020-05-02 12:46:03.660824134 -0700
@@ -41,6 +41,10 @@
 # define BE32(n)	be32toh (n)
 # define BE64(n)	be64toh (n)
 
+#ifndef powerof2
+#define powerof2(x)     ((((x) - 1) & (x)) == 0)
+#endif
+
 #ifndef MAX
 #define MAX(m, n) ((m) < (n) ? (n) : (m))
 #endif
@@ -70,6 +74,38 @@
      __res; })
 #endif
 
+static inline ssize_t 
+pwrite (int fd, const void *buf, size_t len, off_t off)
+{
+  long long filePos = _lseeki64 (fd, off, SEEK_SET);
+  int writeResult = -1;
+  if(filePos == -1L)
+  {
+	  return filePos;
+  }
+
+  writeResult = _write(fd, buf, len);
+  _lseeki64 (fd, filePos, SEEK_SET);
+
+  return writeResult;
+}
+
+static inline ssize_t 
+pread (int fd, void *buf, size_t len, off_t off)
+{
+  long long filePos = _lseeki64 (fd, off, SEEK_SET);
+  int readResult = -1;
+  if(filePos == -1L)
+  {
+	  return filePos;
+  }
+
+  readResult = _read(fd, buf, len);
+  _lseeki64 (fd, filePos, SEEK_SET);
+
+  return readResult;
+}
+
 static inline ssize_t __attribute__ ((unused))
 pwrite_retry (int fd, const void *buf, size_t len, off_t off)
 {
@@ -137,4 +173,8 @@
   extern int never_defined_just_used_for_checking[(expr) ? 1 : -1]	\
     __attribute__ ((unused))
 
+#define S_ISUID 0004000
+#define S_ISGID 0002000
+#define S_ISVTX 0001000
+
 #endif /* system.h */
diff -Naur Retro68.old/Rez/CMakeLists.txt Retro68/Rez/CMakeLists.txt
--- Retro68.old/Rez/CMakeLists.txt	2020-03-19 19:23:34.025534447 -0700
+++ Retro68/Rez/CMakeLists.txt	2020-03-19 19:25:57.705531885 -0700
@@ -15,7 +15,7 @@
 #   You should have received a copy of the GNU General Public License
 #   along with Retro68.  If not, see <http://www.gnu.org/licenses/>.
 
-find_package(Boost COMPONENTS wave filesystem system thread regex program_options)
+find_package(Boost COMPONENTS wave filesystem system thread_win32 regex program_options)
 
 # Look for bison.
     # We need Version 3, and Mac OS X still comes with an outdated version (2.3).
